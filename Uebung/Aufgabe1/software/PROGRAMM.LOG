KCPSM3 Assembler log file for program 'programm.psm'.
Generated by KCPSM3 version 1.30
Ken Chapman (Xilinx Ltd) 2005.
12Nov2018-21:11:18

 Addr Code

 000                          CONSTANT IO_Port, 00
 000                          CONSTANT LED0, 01
 000                          CONSTANT LED1, 02
 000                          CONSTANT BNT0, 04
 000                          CONSTANT COM_Port, 01
 000                          CONSTANT TXD, 01
 000                          CONSTANT RXD, 01
 000                          CONSTANT MIN_NUM, 30
 000                          CONSTANT MAX_NUM, 3A
 000                          CONSTANT MIN_BA, 41
 000                          CONSTANT MAX_BA, 5B
 000                          CONSTANT MIN_SA, 61
 000                          CONSTANT MAX_SA, 7B
 000                          ; Register Mapping
 000                          ; alle acht Register s0 bis sF stehen der ISR zur Verfuegung
 000                          NAMEREG s0, IOR
 000                          NAMEREG s1, TMP
 000                          NAMEREG s2, CNTH
 000                          NAMEREG s3, CNTL
 000                          NAMEREG s4, MOD8
 000                          NAMEREG s5, MOD16
 000                          NAMEREG s6, IN_STATE
 000                          NAMEREG s7, OUT_STATE
 000                          NAMEREG s8, DATA_BUFFER
 000                          NAMEREG s9, WRITE_BUFFER
 000                          NAMEREG sA, MOD16_W
 000                          NAMEREG sB, MOD8_W
 000                          ; --------------------------------------------------------------------------------------------
 000                          ADDRESS 000
 000                          ; Hauptfunktion
 000  0A200            start: AND CNTH[s2], 00                       ; Initialisierung der Zaehlers ...
 001  0A300                   AND CNTL[s3], 00                       ; in der ISR
 002  0A600                   AND IN_STATE[s6], 00
 003  0A700                   AND OUT_STATE[s7], 00
 004  00408                   LOAD MOD8[s4], 08                      ; Initialisierung des modulo 8 Zaehlers
 005  0050F                   LOAD MOD16[s5], 0F                     ; Initialisierung des modulo 8 Zaehlers
 006  00A0F                   LOAD MOD16_W[sA], 0F
 007  00B08                   LOAD MOD8_W[sB], 08
 008  3C001                   ENABLE INTERRUPT
 009                    loop: ; do nothing
 009  34009                   JUMP loop[009]
 00A                          ; --------------------------------------------------------------------------------------------
 00A                          ; Subroutine, die den Zustand des Buttons BTN0 auf die Leuchtdiode LED0 durchschaltet
 00A                BNT0LED0: 
 00A  04000                   INPUT IOR[s0], IO_Port[00]             ; IO-Port einlesen
 00B  04100                   INPUT TMP[s1], IO_Port[00]             ; IO-Port einlesen
 00C  0A104                   AND TMP[s1], BNT0[04]                  ; Zustand von BNT0 ermitteln
 00D  2010E                   SR0 TMP[s1]                            ; auf die Position ...
 00E  2010E                   SR0 TMP[s1]                            ; ... von LED0 verschieben
 00F  0A002                   AND IOR[s0], LED1[02]                  ; Zustand von LED1 ermitteln
 010  0D010                   OR IOR[s0], TMP[s1]                    ; LED1 mit BNT0 konkatinieren
 011  2C000                   OUTPUT IOR[s0], IO_Port[00]            ; den neuen Wert ueber IO-Port ausgeben
 012  2A000                   RETURN
 013                          ; --------------------------------------------------------------------------------------------
 013                          ; Subroutine, die die Leuchtdione LED1 mit ca. 1 Hz blinken laesst
 013  18301            BLINK: ADD CNTL[s3], 01                       ; den 16-Bit-Zaehler ...
 014  1A200                   ADDCY CNTH[s2], 00                     ; .. inkrementieren
 015  35C19                   JUMP NC, BLINK0[019]                   ; kein Ueberlauf -> exit, sonst
 016  04000                   INPUT IOR[s0], IO_Port[00]             ; IO-Port einlesen
 017  0E002                   XOR IOR[s0], LED1[02]                  ; LED1 toggeln
 018  2C000                   OUTPUT IOR[s0], IO_Port[00]            ; den neuen Wert ueber IO-Port ausgeben
 019  2A000           BLINK0: RETURN
 01A                          ; --------------------------------------------------------------------------------------------
 01A                          ; Subroutine, die Daten ueber das serielle Eingangssignal RXD abtastet,
 01A                          ; zu einem Byte zusammensetzt, entscheidet, ob das empfangene Byte
 01A                          ; ein Buchstabe oder eine Ziffer ist, und ggf. das Byte seriell
 01A                          ; ueber das serielle Ausgangssignal TXD ausgibt
 01A                          ;
 01A                          ; in dieser Version ist eine einfache Echo-Funktion implementiert
 01A                 COMM_IN: 
 01A  04001                   INPUT IOR[s0], COM_Port[01]            ; COM_Port einlesen
 01B                          ;       AND     IOR,   RXD      ; Zustand von RXD ermitteln
 01B  14600                   COMPARE IN_STATE[s6], 00
 01C  35025                   JUMP Z, FALLINGFLANK[025]
 01D  14601                   COMPARE IN_STATE[s6], 01
 01E  35029                   JUMP Z, STARTBIT[029]
 01F  14602                   COMPARE IN_STATE[s6], 02
 020  35031                   JUMP Z, RECDATA[031]
 021  14603                   COMPARE IN_STATE[s6], 03
 022  3503B                   JUMP Z, STOPPBIT[03B]
 023  2C001                   OUTPUT IOR[s0], COM_Port[01]           ; TXD ausgeben
 024  2A000                   RETURN
 025                          ; idle, fallende flanke, start bit erkannt wenn nicht abbrechen, daten, stoppbit
 025                          ; mod 16 für daten
 025                          ; mod 8 für immer
 025                          ; --------------------------------------------------------------------------------------------
 025                          ; Subroutine, die überprüft ob die fallende Flanke nur eine Leitungsstörung
 025                          ; war, oder ob es sich wirklich um das Startbit handelt.
 025                          ; Modulo 8 Zähler um in der Mitte der Übertragung nochmal zu überprüfen (16-fache Abtastung).
 025            FALLINGFLANK: 
 025  14000                   COMPARE IOR[s0], 00
 026  2B400                   RETURN NZ
 027  18601                   ADD IN_STATE[s6], 01
 028  2A000                   RETURN
 029                          ; --------------------------------------------------------------------------------------------
 029                          ; Subroutine, die überprüft ob die fallende Flanke nur eine Leitungsstörung
 029                          ; war, oder ob es sich wirklich um das Startbit handelt.
 029                          ; Modulo 8 Zähler um in der Mitte der Übertragung nochmal zu überprüfen (16-fache Abtastung).
 029                STARTBIT: 
 029  1C401                   SUB MOD8[s4], 01
 02A  2B400                   RETURN NZ
 02B  00408                   LOAD MOD8[s4], 08
 02C  14000                   COMPARE IOR[s0], 00
 02D  2B400                   RETURN NZ
 02E  18601                   ADD IN_STATE[s6], 01
 02F  00800                   LOAD DATA_BUFFER[s8], 00
 030  2A000                   RETURN
 031                          ; --------------------------------------------------------------------------------------------
 031                          ; Subroutine, die
 031                 RECDATA: 
 031  1C501                   SUB MOD16[s5], 01
 032  2B400                   RETURN NZ
 033  0050F                   LOAD MOD16[s5], 0F
 034  2080C                   RR DATA_BUFFER[s8]
 035  0D800                   OR DATA_BUFFER[s8], IOR[s0]
 036  1C401                   SUB MOD8[s4], 01
 037  2B400                   RETURN NZ
 038  18601                   ADD IN_STATE[s6], 01
 039  00408                   LOAD MOD8[s4], 08
 03A  2A000                   RETURN
 03B                          ; --------------------------------------------------------------------------------------------
 03B                          ; Subroutine,
 03B                STOPPBIT: 
 03B  1C501                   SUB MOD16[s5], 01
 03C  2B400                   RETURN NZ
 03D  00600                   LOAD IN_STATE[s6], 00
 03E  0050F                   LOAD MOD16[s5], 0F
 03F  14001                   COMPARE IOR[s0], 01
 040  2B400                   RETURN NZ
 041  00701                   LOAD OUT_STATE[s7], 01
 042  34043                   JUMP DATA_PROCESSING[043]
 043                          ; --------------------------------------------------------------------------------------------
 043                          ; Subroutine,
 043         DATA_PROCESSING: 
 043  14830                   COMPARE DATA_BUFFER[s8], MIN_NUM[30]
 044  2B800                   RETURN C
 045  1483A                   COMPARE DATA_BUFFER[s8], MAX_NUM[3A]
 046  3584F                   JUMP C, WRITE_ENABLE[04F]
 047  14841                   COMPARE DATA_BUFFER[s8], MIN_BA[41]
 048  2B800                   RETURN C
 049  1485B                   COMPARE DATA_BUFFER[s8], MAX_BA[5B]
 04A  3584F                   JUMP C, WRITE_ENABLE[04F]
 04B  14861                   COMPARE DATA_BUFFER[s8], MIN_SA[61]
 04C  2B800                   RETURN C
 04D  1487B                   COMPARE DATA_BUFFER[s8], MAX_SA[7B]
 04E  3584F                   JUMP C, WRITE_ENABLE[04F]
 04F                          ; --------------------------------------------------------------------------------------------
 04F                          ; Subroutine, die
 04F            WRITE_ENABLE: 
 04F  01980                   LOAD WRITE_BUFFER[s9], DATA_BUFFER[s8]
 050  18700                   ADD OUT_STATE[s7], 00
 051  2A000                   RETURN
 052                          ; --------------------------------------------------------------------------------------------
 052                          ; Subroutine, die
 052                COMM_OUT: 
 052  14700                   COMPARE OUT_STATE[s7], 00
 053  35058                   JUMP Z, W_STARTBIT[058]
 054  14701                   COMPARE OUT_STATE[s7], 01
 055  3505C                   JUMP Z, W_DATA[05C]
 056  14702                   COMPARE OUT_STATE[s7], 02
 057  35066                   JUMP Z, W_STOPPBIT[066]
 058                          ; --------------------------------------------------------------------------------------------
 058                          ; Subroutine, die
 058              W_STARTBIT: 
 058  0A000                   AND IOR[s0], 00
 059  2C001                   OUTPUT IOR[s0], COM_Port[01]
 05A  18701                   ADD OUT_STATE[s7], 01
 05B  2A000                   RETURN
 05C                          ; --------------------------------------------------------------------------------------------
 05C                          ; Subroutine, die
 05C                  W_DATA: 
 05C  1CA01                   SUB MOD16_W[sA], 01
 05D  2B400                   RETURN NZ
 05E  00A0F                   LOAD MOD16_W[sA], 0F
 05F  2C901                   OUTPUT WRITE_BUFFER[s9], COM_Port[01]
 060  2090C                   RR WRITE_BUFFER[s9]
 061  1CB01                   SUB MOD8_W[sB], 01
 062  2B400                   RETURN NZ
 063  00B08                   LOAD MOD8_W[sB], 08
 064  18701                   ADD OUT_STATE[s7], 01
 065  2A000                   RETURN
 066                          ; --------------------------------------------------------------------------------------------
 066                          ; Subroutine, die
 066              W_STOPPBIT: 
 066  1CA01                   SUB MOD16_W[sA], 01
 067  2B400                   RETURN NZ
 068  00001                   LOAD IOR[s0], 01
 069  2C001                   OUTPUT IOR[s0], COM_Port[01]
 06A  18701                   ADD OUT_STATE[s7], 01
 06B  2A000                   RETURN
 06C                          ; --------------------------------------------------------------------------------------------
 300                          ADDRESS 300
 300                          ; Interrupt-Service-Routine
 300  30052              ISR: CALL COMM_OUT[052]
 301  3001A                   CALL COMM_IN[01A]
 302  3000A                   CALL BNT0LED0[00A]
 303  30013                   CALL BLINK[013]
 304  38001                   RETURNI ENABLE
 305                          ; --------------------------------------------------------------------------------------------
 305                          ; Interrupt-Vektor
 3FF                          ADDRESS 3FF
 3FF  34300                   JUMP ISR[300]

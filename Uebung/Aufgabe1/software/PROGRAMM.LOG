KCPSM3 Assembler log file for program 'programm.psm'.
Generated by KCPSM3 version 1.30
Ken Chapman (Xilinx Ltd) 2005.
02Dec2018-11:28:23

 Addr Code

 000                       CONSTANT IO_Port, 00
 000                       CONSTANT LED0, 01
 000                       CONSTANT LED1, 02
 000                       CONSTANT BNT0, 04
 000                       CONSTANT COM_Port, 01
 000                       CONSTANT TXD, 01
 000                       CONSTANT RXD, 01
 000                       CONSTANT MIN_NUM, 30
 000                       CONSTANT MAX_NUM, 3A
 000                       CONSTANT MIN_BA, 41
 000                       CONSTANT MAX_BA, 5B
 000                       CONSTANT MIN_SA, 61
 000                       CONSTANT MAX_SA, 7B
 000                       ; Register Mapping
 000                       ; alle acht Register s0 bis sF stehen der ISR zur Verfuegung
 000                       NAMEREG s0, IOR
 000                       NAMEREG s1, TMP
 000                       NAMEREG s2, CNTH
 000                       NAMEREG s3, CNTL
 000                       NAMEREG s4, MOD8
 000                       NAMEREG s5, MOD16
 000                       NAMEREG s6, IN_STATE
 000                       NAMEREG s7, OUT_STATE
 000                       NAMEREG s8, DATA_BUFFER
 000                       NAMEREG s9, WRITE_BUFFER
 000                       NAMEREG sA, MOD16_W
 000                       NAMEREG sB, MOD8_W
 000                       NAMEREG sC, WRITE_ENABLE
 000                       ; --------------------------------------------------------------------------------------------
 000                       ADDRESS 000
 000                       ; Hauptfunktion
 000  0A200         start: AND CNTH[s2], 00                       ; Initialisierung des Zaehlers ...
 001  0A300                AND CNTL[s3], 00                       ; in der ISR
 002  00600                LOAD IN_STATE[s6], 00
 003  00700                LOAD OUT_STATE[s7], 00
 004  00408                LOAD MOD8[s4], 08                      ; Initialisierung des modulo 8 Zaehlers
 005  00510                LOAD MOD16[s5], 10                     ; Initialisierung des modulo 8 Zaehlers
 006  00A10                LOAD MOD16_W[sA], 10
 007  00B08                LOAD MOD8_W[sB], 08
 008  00800                LOAD DATA_BUFFER[s8], 00
 009  00900                LOAD WRITE_BUFFER[s9], 00
 00A  00C00                LOAD WRITE_ENABLE[sC], 00
 00B  3C001                ENABLE INTERRUPT
 00C                 loop: ; do nothing
 00C  3400C                JUMP loop[00C]
 00D                       ; --------------------------------------------------------------------------------------------
 00D                       ; Subroutine, die den Zustand des Buttons BTN0 auf die Leuchtdiode LED0 durchschaltet
 00D             BNT0LED0: 
 00D  04000                INPUT IOR[s0], IO_Port[00]             ; IO-Port einlesen
 00E  04100                INPUT TMP[s1], IO_Port[00]             ; IO-Port einlesen
 00F  0A104                AND TMP[s1], BNT0[04]                  ; Zustand von BNT0 ermitteln
 010  2010E                SR0 TMP[s1]                            ; auf die Position ...
 011  2010E                SR0 TMP[s1]                            ; ... von LED0 verschieben
 012  0A002                AND IOR[s0], LED1[02]                  ; Zustand von LED1 ermitteln
 013  0D010                OR IOR[s0], TMP[s1]                    ; LED1 mit BNT0 konkatinieren
 014  2C000                OUTPUT IOR[s0], IO_Port[00]            ; den neuen Wert ueber IO-Port ausgeben
 015  2A000                RETURN
 016                       ; --------------------------------------------------------------------------------------------
 016                       ; Subroutine, die die Leuchtdione LED1 mit ca. 1 Hz blinken laesst
 016  18301         BLINK: ADD CNTL[s3], 01                       ; den 16-Bit-Zaehler ...
 017  1A200                ADDCY CNTH[s2], 00                     ; .. inkrementieren
 018  35C1C                JUMP NC, BLINK0[01C]                   ; kein Ueberlauf -> exit, sonst
 019  04000                INPUT IOR[s0], IO_Port[00]             ; IO-Port einlesen
 01A  0E002                XOR IOR[s0], LED1[02]                  ; LED1 toggeln
 01B  2C000                OUTPUT IOR[s0], IO_Port[00]            ; den neuen Wert ueber IO-Port ausgeben
 01C  2A000        BLINK0: RETURN
 01D                       ; --------------------------------------------------------------------------------------------
 01D                       ; Subroutine, die Daten ueber das serielle Eingangssignal RXD abtastet,
 01D                       ; zu einem Byte zusammensetzt, entscheidet, ob das empfangene Byte
 01D                       ; ein Buchstabe oder eine Ziffer ist, und ggf. das Byte seriell
 01D                       ; ueber das serielle Ausgangssignal TXD ausgibt
 01D                       ;
 01D                       ; in dieser Version ist eine einfache Echo-Funktion implementiert
 01D              COMM_IN: 
 01D                       ;       AND     IOR,   RXD      ; Zustand von RXD ermitteln
 01D  14602                COMPARE IN_STATE[s6], 02
 01E  35037                JUMP Z, RECDATA[037]
 01F  14600                COMPARE IN_STATE[s6], 00
 020  35029                JUMP Z, FALLINGFLANK[029]
 021  14601                COMPARE IN_STATE[s6], 01
 022  3502E                JUMP Z, STARTBIT[02E]
 023  14603                COMPARE IN_STATE[s6], 03
 024  35042                JUMP Z, STOPPBIT[042]
 025  1CA01                SUB MOD16_W[sA], 01
 026  2B400                RETURN NZ
 027  00A10                LOAD MOD16_W[sA], 10
 028  2A000                RETURN
 029                       ; idle, fallende flanke, start bit erkannt wenn nicht abbrechen, daten, stoppbit
 029                       ; mod 16 für daten
 029                       ; mod 8 für immer
 029                       ; --------------------------------------------------------------------------------------------
 029                       ; Subroutine, die überprüft ob die fallende Flanke nur eine Leitungsstörung
 029                       ; war, oder ob es sich wirklich um das Startbit handelt.
 029                       ; Modulo 8 Zähler um in der Mitte der Übertragung nochmal zu überprüfen (16-fache Abtastung).
 029         FALLINGFLANK: 
 029  04001                INPUT IOR[s0], COM_Port[01]            ; COM_Port einlesen
 02A  14000                COMPARE IOR[s0], 00
 02B  2B400                RETURN NZ
 02C  18601                ADD IN_STATE[s6], 01
 02D  2A000                RETURN
 02E                       ; --------------------------------------------------------------------------------------------
 02E                       ; Subroutine, die überprüft ob die fallende Flanke nur eine Leitungsstörung
 02E                       ; war, oder ob es sich wirklich um das Startbit handelt.
 02E                       ; Modulo 8 Zähler um in der Mitte der Übertragung nochmal zu überprüfen (16-fache Abtastung).
 02E             STARTBIT: 
 02E  1C401                SUB MOD8[s4], 01
 02F  2B400                RETURN NZ
 030  00408                LOAD MOD8[s4], 08
 031  04001                INPUT IOR[s0], COM_Port[01]            ; COM_Port einlesen
 032  14000                COMPARE IOR[s0], 00
 033  35459                JUMP NZ, RESET[059]
 034  18601                ADD IN_STATE[s6], 01
 035  00800                LOAD DATA_BUFFER[s8], 00
 036  2A000                RETURN
 037                       ; --------------------------------------------------------------------------------------------
 037                       ; Subroutine, die
 037              RECDATA: 
 037  1C501                SUB MOD16[s5], 01
 038  2B400                RETURN NZ
 039  00510                LOAD MOD16[s5], 10
 03A  04001                INPUT IOR[s0], COM_Port[01]            ; COM_Port einlesen
 03B  0D800                OR DATA_BUFFER[s8], IOR[s0]
 03C  2080C                RR DATA_BUFFER[s8]
 03D  1C401                SUB MOD8[s4], 01
 03E  2B400                RETURN NZ
 03F  00408                LOAD MOD8[s4], 08
 040  18601                ADD IN_STATE[s6], 01
 041  2A000                RETURN
 042                       ; --------------------------------------------------------------------------------------------
 042                       ; Subroutine,
 042             STOPPBIT: 
 042  1C501                SUB MOD16[s5], 01
 043  2B400                RETURN NZ
 044  00600                LOAD IN_STATE[s6], 00
 045  00510                LOAD MOD16[s5], 10
 046  04001                INPUT IOR[s0], COM_Port[01]            ; COM_Port einlesen
 047  14001                COMPARE IOR[s0], 01
 048  2B400                RETURN NZ
 049  14830                COMPARE DATA_BUFFER[s8], MIN_NUM[30]
 04A  2B800                RETURN C
 04B  1483A                COMPARE DATA_BUFFER[s8], MAX_NUM[3A]
 04C  35856                JUMP C, WRITE[056]
 04D  1487B                COMPARE DATA_BUFFER[s8], MAX_SA[7B]
 04E  2BC00                RETURN NC
 04F  14841                COMPARE DATA_BUFFER[s8], MIN_BA[41]
 050  2B800                RETURN C
 051  1485B                COMPARE DATA_BUFFER[s8], MAX_BA[5B]
 052  35856                JUMP C, WRITE[056]
 053  14861                COMPARE DATA_BUFFER[s8], MIN_SA[61]
 054  2B800                RETURN C
 055  34056                JUMP WRITE[056]
 056                       ; --------------------------------------------------------------------------------------------
 056                       ; Subroutine, die
 056                WRITE: 
 056  01980                LOAD WRITE_BUFFER[s9], DATA_BUFFER[s8]
 057  00C01                LOAD WRITE_ENABLE[sC], 01
 058  2A000                RETURN
 059                       ; --------------------------------------------------------------------------------------------
 059                RESET: 
 059  00600                LOAD IN_STATE[s6], 00
 05A  2A000                RETURN
 05B                       ; --------------------------------------------------------------------------------------------
 05B                       ; Subroutine, die
 05B             COMM_OUT: 
 05B  14C01                COMPARE WRITE_ENABLE[sC], 01
 05C  2B400                RETURN NZ
 05D  14701                COMPARE OUT_STATE[s7], 01
 05E  3506B                JUMP Z, W_DATA[06B]
 05F  14700                COMPARE OUT_STATE[s7], 00
 060  35064                JUMP Z, W_STARTBIT[064]
 061  14702                COMPARE OUT_STATE[s7], 02
 062  35075                JUMP Z, W_STOPPBIT[075]
 063  2A000                RETURN
 064                       ; --------------------------------------------------------------------------------------------
 064                       ; Subroutine, die
 064           W_STARTBIT: 
 064  1CA01                SUB MOD16_W[sA], 01
 065  2B400                RETURN NZ
 066  00A10                LOAD MOD16_W[sA], 10
 067  0A000                AND IOR[s0], 00
 068  2C001                OUTPUT IOR[s0], COM_Port[01]
 069  18701                ADD OUT_STATE[s7], 01
 06A  2A000                RETURN
 06B                       ; --------------------------------------------------------------------------------------------
 06B                       ; Subroutine, die
 06B               W_DATA: 
 06B  1CA01                SUB MOD16_W[sA], 01
 06C  2B400                RETURN NZ
 06D  00A10                LOAD MOD16_W[sA], 10
 06E  2C901                OUTPUT WRITE_BUFFER[s9], COM_Port[01]
 06F  2090C                RR WRITE_BUFFER[s9]
 070  1CB01                SUB MOD8_W[sB], 01
 071  2B400                RETURN NZ
 072  00B08                LOAD MOD8_W[sB], 08
 073  18701                ADD OUT_STATE[s7], 01
 074  2A000                RETURN
 075                       ; --------------------------------------------------------------------------------------------
 075                       ; Subroutine, die
 075           W_STOPPBIT: 
 075  1CA01                SUB MOD16_W[sA], 01
 076  2B400                RETURN NZ
 077  00A10                LOAD MOD16_W[sA], 10
 078  00101                LOAD TMP[s1], 01
 079  2C101                OUTPUT TMP[s1], COM_Port[01]
 07A  00700                LOAD OUT_STATE[s7], 00
 07B  00C00                LOAD WRITE_ENABLE[sC], 00
 07C  2A000                RETURN
 07D                       ; --------------------------------------------------------------------------------------------
 300                       ADDRESS 300
 300                       ; Interrupt-Service-Routine
 300  3005B           ISR: CALL COMM_OUT[05B]
 301  3001D                CALL COMM_IN[01D]
 302  3000D                CALL BNT0LED0[00D]
 303  30016                CALL BLINK[016]
 304  38001                RETURNI ENABLE
 305                       ; --------------------------------------------------------------------------------------------
 305                       ; Interrupt-Vektor
 3FF                       ADDRESS 3FF
 3FF  34300                JUMP ISR[300]

KCPSM3 Assembler log file for program 'programm.psm'.
Generated by KCPSM3 version 1.30
Ken Chapman (Xilinx Ltd) 2005.
13Nov2018-10:00:01

 Addr Code

 000                          CONSTANT IO_Port, 00
 000                          CONSTANT LED0, 01
 000                          CONSTANT LED1, 02
 000                          CONSTANT BNT0, 04
 000                          CONSTANT COM_Port, 01
 000                          CONSTANT TXD, 01
 000                          CONSTANT RXD, 01
 000                          CONSTANT MIN_NUM, 30
 000                          CONSTANT MAX_NUM, 3A
 000                          CONSTANT MIN_BA, 41
 000                          CONSTANT MAX_BA, 5B
 000                          CONSTANT MIN_SA, 61
 000                          CONSTANT MAX_SA, 7B
 000                          ; Register Mapping
 000                          ; alle acht Register s0 bis sF stehen der ISR zur Verfuegung
 000                          NAMEREG s0, IOR
 000                          NAMEREG s1, TMP
 000                          NAMEREG s2, CNTH
 000                          NAMEREG s3, CNTL
 000                          NAMEREG s4, MOD8
 000                          NAMEREG s5, MOD16
 000                          NAMEREG s6, IN_STATE
 000                          NAMEREG s7, OUT_STATE
 000                          NAMEREG s8, DATA_BUFFER
 000                          NAMEREG s9, WRITE_BUFFER
 000                          NAMEREG sA, MOD16_W
 000                          NAMEREG sB, MOD8_W
 000                          NAMEREG sD, ONE_OUT
 000                          ; --------------------------------------------------------------------------------------------
 000                          ADDRESS 000
 000                          ; Hauptfunktion
 000  0A200            start: AND CNTH[s2], 00                       ; Initialisierung der Zaehlers ...
 001  0A300                   AND CNTL[s3], 00                       ; in der ISR
 002  0A600                   AND IN_STATE[s6], 00
 003  0A705                   AND OUT_STATE[s7], 05
 004  00408                   LOAD MOD8[s4], 08                      ; Initialisierung des modulo 8 Zaehlers
 005  00510                   LOAD MOD16[s5], 10                     ; Initialisierung des modulo 8 Zaehlers
 006  00A10                   LOAD MOD16_W[sA], 10
 007  00B08                   LOAD MOD8_W[sB], 08
 008  0A800                   AND DATA_BUFFER[s8], 00
 009  0A900                   AND WRITE_BUFFER[s9], 00
 00A  00D01                   LOAD ONE_OUT[sD], 01
 00B  3C001                   ENABLE INTERRUPT
 00C                    loop: ; do nothing
 00C  3400C                   JUMP loop[00C]
 00D                          ; --------------------------------------------------------------------------------------------
 00D                          ; Subroutine, die den Zustand des Buttons BTN0 auf die Leuchtdiode LED0 durchschaltet
 00D                BNT0LED0: 
 00D  04000                   INPUT IOR[s0], IO_Port[00]             ; IO-Port einlesen
 00E  04100                   INPUT TMP[s1], IO_Port[00]             ; IO-Port einlesen
 00F  0A104                   AND TMP[s1], BNT0[04]                  ; Zustand von BNT0 ermitteln
 010  2010E                   SR0 TMP[s1]                            ; auf die Position ...
 011  2010E                   SR0 TMP[s1]                            ; ... von LED0 verschieben
 012  0A002                   AND IOR[s0], LED1[02]                  ; Zustand von LED1 ermitteln
 013  0D010                   OR IOR[s0], TMP[s1]                    ; LED1 mit BNT0 konkatinieren
 014  2C000                   OUTPUT IOR[s0], IO_Port[00]            ; den neuen Wert ueber IO-Port ausgeben
 015  2A000                   RETURN
 016                          ; --------------------------------------------------------------------------------------------
 016                          ; Subroutine, die die Leuchtdione LED1 mit ca. 1 Hz blinken laesst
 016  18301            BLINK: ADD CNTL[s3], 01                       ; den 16-Bit-Zaehler ...
 017  1A200                   ADDCY CNTH[s2], 00                     ; .. inkrementieren
 018  35C1C                   JUMP NC, BLINK0[01C]                   ; kein Ueberlauf -> exit, sonst
 019  04000                   INPUT IOR[s0], IO_Port[00]             ; IO-Port einlesen
 01A  0E002                   XOR IOR[s0], LED1[02]                  ; LED1 toggeln
 01B  2C000                   OUTPUT IOR[s0], IO_Port[00]            ; den neuen Wert ueber IO-Port ausgeben
 01C  2A000           BLINK0: RETURN
 01D                          ; --------------------------------------------------------------------------------------------
 01D                          ; Subroutine, die Daten ueber das serielle Eingangssignal RXD abtastet,
 01D                          ; zu einem Byte zusammensetzt, entscheidet, ob das empfangene Byte
 01D                          ; ein Buchstabe oder eine Ziffer ist, und ggf. das Byte seriell
 01D                          ; ueber das serielle Ausgangssignal TXD ausgibt
 01D                          ;
 01D                          ; in dieser Version ist eine einfache Echo-Funktion implementiert
 01D                 COMM_IN: 
 01D  04001                   INPUT IOR[s0], COM_Port[01]            ; COM_Port einlesen
 01E                          ;       AND     IOR,   RXD      ; Zustand von RXD ermitteln
 01E  14602                   COMPARE IN_STATE[s6], 02
 01F  35036                   JUMP Z, RECDATA[036]
 020  14600                   COMPARE IN_STATE[s6], 00
 021  3502A                   JUMP Z, FALLINGFLANK[02A]
 022  14601                   COMPARE IN_STATE[s6], 01
 023  3502E                   JUMP Z, STARTBIT[02E]
 024  14603                   COMPARE IN_STATE[s6], 03
 025  35040                   JUMP Z, STOPPBIT[040]
 026  1CA01                   SUB MOD16_W[sA], 01
 027  2B400                   RETURN NZ
 028  00A10                   LOAD MOD16_W[sA], 10
 029  2A000                   RETURN
 02A                          ; idle, fallende flanke, start bit erkannt wenn nicht abbrechen, daten, stoppbit
 02A                          ; mod 16 für daten
 02A                          ; mod 8 für immer
 02A                          ; --------------------------------------------------------------------------------------------
 02A                          ; Subroutine, die überprüft ob die fallende Flanke nur eine Leitungsstörung
 02A                          ; war, oder ob es sich wirklich um das Startbit handelt.
 02A                          ; Modulo 8 Zähler um in der Mitte der Übertragung nochmal zu überprüfen (16-fache Abtastung).
 02A            FALLINGFLANK: 
 02A  14000                   COMPARE IOR[s0], 00
 02B  2B400                   RETURN NZ
 02C  18601                   ADD IN_STATE[s6], 01
 02D  2A000                   RETURN
 02E                          ; --------------------------------------------------------------------------------------------
 02E                          ; Subroutine, die überprüft ob die fallende Flanke nur eine Leitungsstörung
 02E                          ; war, oder ob es sich wirklich um das Startbit handelt.
 02E                          ; Modulo 8 Zähler um in der Mitte der Übertragung nochmal zu überprüfen (16-fache Abtastung).
 02E                STARTBIT: 
 02E  1C401                   SUB MOD8[s4], 01
 02F  2B400                   RETURN NZ
 030  00408                   LOAD MOD8[s4], 08
 031  14000                   COMPARE IOR[s0], 00
 032  35458                   JUMP NZ, RESET[058]
 033  18601                   ADD IN_STATE[s6], 01
 034  00800                   LOAD DATA_BUFFER[s8], 00
 035  2A000                   RETURN
 036                          ; --------------------------------------------------------------------------------------------
 036                          ; Subroutine, die
 036                 RECDATA: 
 036  1C501                   SUB MOD16[s5], 01
 037  2B400                   RETURN NZ
 038  00510                   LOAD MOD16[s5], 10
 039  0D800                   OR DATA_BUFFER[s8], IOR[s0]
 03A  2080C                   RR DATA_BUFFER[s8]
 03B  1C401                   SUB MOD8[s4], 01
 03C  2B400                   RETURN NZ
 03D  18601                   ADD IN_STATE[s6], 01
 03E  00408                   LOAD MOD8[s4], 08
 03F  2A000                   RETURN
 040                          ; --------------------------------------------------------------------------------------------
 040                          ; Subroutine,
 040                STOPPBIT: 
 040  1C501                   SUB MOD16[s5], 01
 041  2B400                   RETURN NZ
 042  00600                   LOAD IN_STATE[s6], 00
 043  00510                   LOAD MOD16[s5], 10
 044  14001                   COMPARE IOR[s0], 01
 045  2B400                   RETURN NZ
 046  34047                   JUMP DATA_PROCESSING[047]
 047                          ; --------------------------------------------------------------------------------------------
 047                          ; Subroutine,
 047         DATA_PROCESSING: 
 047  1487B                   COMPARE DATA_BUFFER[s8], MAX_SA[7B]
 048  2BC00                   RETURN NC
 049  14830                   COMPARE DATA_BUFFER[s8], MIN_NUM[30]
 04A  2B800                   RETURN C
 04B  1483A                   COMPARE DATA_BUFFER[s8], MAX_NUM[3A]
 04C  35855                   JUMP C, WRITE_ENABLE[055]
 04D  14841                   COMPARE DATA_BUFFER[s8], MIN_BA[41]
 04E  2B800                   RETURN C
 04F  1485B                   COMPARE DATA_BUFFER[s8], MAX_BA[5B]
 050  35855                   JUMP C, WRITE_ENABLE[055]
 051  14861                   COMPARE DATA_BUFFER[s8], MIN_SA[61]
 052  2B800                   RETURN C
 053  1487B                   COMPARE DATA_BUFFER[s8], MAX_SA[7B]
 054  35855                   JUMP C, WRITE_ENABLE[055]
 055                          ; --------------------------------------------------------------------------------------------
 055                          ; Subroutine, die
 055            WRITE_ENABLE: 
 055  01980                   LOAD WRITE_BUFFER[s9], DATA_BUFFER[s8]
 056  00700                   LOAD OUT_STATE[s7], 00
 057  2A000                   RETURN
 058                          ; --------------------------------------------------------------------------------------------
 058                   RESET: 
 058  00600                   LOAD IN_STATE[s6], 00
 059  2A000                   RETURN
 05A                          ; --------------------------------------------------------------------------------------------
 05A                          ; Subroutine, die
 05A                COMM_OUT: 
 05A  14700                   COMPARE OUT_STATE[s7], 00
 05B  35062                   JUMP Z, W_STARTBIT[062]
 05C  14701                   COMPARE OUT_STATE[s7], 01
 05D  3506A                   JUMP Z, W_DATA[06A]
 05E  14702                   COMPARE OUT_STATE[s7], 02
 05F  35073                   JUMP Z, W_STOPPBIT[073]
 060  2CD01                   OUTPUT ONE_OUT[sD], COM_Port[01]
 061  2A000                   RETURN
 062                          ; --------------------------------------------------------------------------------------------
 062                          ; Subroutine, die
 062              W_STARTBIT: 
 062  1CA01                   SUB MOD16_W[sA], 01
 063  2B400                   RETURN NZ
 064  00A10                   LOAD MOD16_W[sA], 10
 065  0A000                   AND IOR[s0], 00
 066  2C001                   OUTPUT IOR[s0], COM_Port[01]
 067  18701                   ADD OUT_STATE[s7], 01
 068  00B08                   LOAD MOD8_W[sB], 08
 069  2A000                   RETURN
 06A                          ; --------------------------------------------------------------------------------------------
 06A                          ; Subroutine, die
 06A                  W_DATA: 
 06A  1CA01                   SUB MOD16_W[sA], 01
 06B  2B400                   RETURN NZ
 06C  00A10                   LOAD MOD16_W[sA], 10
 06D  2C901                   OUTPUT WRITE_BUFFER[s9], COM_Port[01]
 06E  2090C                   RR WRITE_BUFFER[s9]
 06F  1CB01                   SUB MOD8_W[sB], 01
 070  2B400                   RETURN NZ
 071  18701                   ADD OUT_STATE[s7], 01
 072  2A000                   RETURN
 073                          ; --------------------------------------------------------------------------------------------
 073                          ; Subroutine, die
 073              W_STOPPBIT: 
 073  1CA01                   SUB MOD16_W[sA], 01
 074  2B400                   RETURN NZ
 075  00A10                   LOAD MOD16_W[sA], 10
 076  2CD01                   OUTPUT ONE_OUT[sD], COM_Port[01]
 077  18701                   ADD OUT_STATE[s7], 01
 078  2A000                   RETURN
 079                          ; --------------------------------------------------------------------------------------------
 300                          ADDRESS 300
 300                          ; Interrupt-Service-Routine
 300  3005A              ISR: CALL COMM_OUT[05A]
 301  3001D                   CALL COMM_IN[01D]
 302  3000D                   CALL BNT0LED0[00D]
 303  30016                   CALL BLINK[016]
 304  38001                   RETURNI ENABLE
 305                          ; --------------------------------------------------------------------------------------------
 305                          ; Interrupt-Vektor
 3FF                          ADDRESS 3FF
 3FF  34300                   JUMP ISR[300]

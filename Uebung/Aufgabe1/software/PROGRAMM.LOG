KCPSM3 Assembler log file for program 'programm.psm'.
Generated by KCPSM3 version 1.30
Ken Chapman (Xilinx Ltd) 2005.
02Dec2018-11:22:58

 Addr Code

 000                       CONSTANT IO_Port, 00
 000                       CONSTANT LED0, 01
 000                       CONSTANT LED1, 02
 000                       CONSTANT BNT0, 04
 000                       CONSTANT COM_Port, 01
 000                       CONSTANT TXD, 01
 000                       CONSTANT RXD, 01
 000                       CONSTANT MIN_NUM, 30
 000                       CONSTANT MAX_NUM, 3A
 000                       CONSTANT MIN_BA, 41
 000                       CONSTANT MAX_BA, 5B
 000                       CONSTANT MIN_SA, 61
 000                       CONSTANT MAX_SA, 7B
 000                       ; Register Mapping
 000                       ; alle acht Register s0 bis sF stehen der ISR zur Verfuegung
 000                       NAMEREG s0, IOR
 000                       NAMEREG s1, TMP
 000                       NAMEREG s2, CNTH
 000                       NAMEREG s3, CNTL
 000                       NAMEREG s4, MOD8
 000                       NAMEREG s5, MOD16
 000                       NAMEREG s6, IN_STATE
 000                       NAMEREG s7, OUT_STATE
 000                       NAMEREG s8, DATA_BUFFER
 000                       NAMEREG s9, WRITE_BUFFER
 000                       NAMEREG sA, MOD16_W
 000                       NAMEREG sB, MOD8_W
 000                       NAMEREG sC, WRITE_ENABLE
 000                       ; --------------------------------------------------------------------------------------------
 000                       ADDRESS 000
 000                       ; Hauptfunktion
 000  0A200         start: AND CNTH[s2], 00                       ; Initialisierung des Zaehlers ...
 001  0A300                AND CNTL[s3], 00                       ; in der ISR
 002  00600                LOAD IN_STATE[s6], 00
 003  00700                LOAD OUT_STATE[s7], 00
 004  00408                LOAD MOD8[s4], 08                      ; Initialisierung des modulo 8 Zaehlers
 005  00510                LOAD MOD16[s5], 10                     ; Initialisierung des modulo 8 Zaehlers
 006  00A10                LOAD MOD16_W[sA], 10
 007  00B08                LOAD MOD8_W[sB], 08
 008  00800                LOAD DATA_BUFFER[s8], 00
 009  00900                LOAD WRITE_BUFFER[s9], 00
 00A  00C00                LOAD WRITE_ENABLE[sC], 00
 00B  3C001                ENABLE INTERRUPT
 00C                 loop: ; do nothing
 00C  3400C                JUMP loop[00C]
 00D                       ; --------------------------------------------------------------------------------------------
 00D                       ; Subroutine, die den Zustand des Buttons BTN0 auf die Leuchtdiode LED0 durchschaltet
 00D             BNT0LED0: 
 00D  04000                INPUT IOR[s0], IO_Port[00]             ; IO-Port einlesen
 00E  04100                INPUT TMP[s1], IO_Port[00]             ; IO-Port einlesen
 00F  0A104                AND TMP[s1], BNT0[04]                  ; Zustand von BNT0 ermitteln
 010  2010E                SR0 TMP[s1]                            ; auf die Position ...
 011  2010E                SR0 TMP[s1]                            ; ... von LED0 verschieben
 012  0A002                AND IOR[s0], LED1[02]                  ; Zustand von LED1 ermitteln
 013  0D010                OR IOR[s0], TMP[s1]                    ; LED1 mit BNT0 konkatinieren
 014  2C000                OUTPUT IOR[s0], IO_Port[00]            ; den neuen Wert ueber IO-Port ausgeben
 015  2A000                RETURN
 016                       ; --------------------------------------------------------------------------------------------
 016                       ; Subroutine, die die Leuchtdione LED1 mit ca. 1 Hz blinken laesst
 016  18301         BLINK: ADD CNTL[s3], 01                       ; den 16-Bit-Zaehler ...
 017  1A200                ADDCY CNTH[s2], 00                     ; .. inkrementieren
 018  35C1C                JUMP NC, BLINK0[01C]                   ; kein Ueberlauf -> exit, sonst
 019  04000                INPUT IOR[s0], IO_Port[00]             ; IO-Port einlesen
 01A  0E002                XOR IOR[s0], LED1[02]                  ; LED1 toggeln
 01B  2C000                OUTPUT IOR[s0], IO_Port[00]            ; den neuen Wert ueber IO-Port ausgeben
 01C  2A000        BLINK0: RETURN
 01D                       ; --------------------------------------------------------------------------------------------
 01D                       ; Subroutine, die Daten ueber das serielle Eingangssignal RXD abtastet,
 01D                       ; zu einem Byte zusammensetzt, entscheidet, ob das empfangene Byte
 01D                       ; ein Buchstabe oder eine Ziffer ist, und ggf. das Byte seriell
 01D                       ; ueber das serielle Ausgangssignal TXD ausgibt
 01D                       ;
 01D                       ; in dieser Version ist eine einfache Echo-Funktion implementiert
 01D              COMM_IN: 
 01D  04001                INPUT IOR[s0], COM_Port[01]            ; COM_Port einlesen
 01E                       ;       AND     IOR,   RXD      ; Zustand von RXD ermitteln
 01E  14602                COMPARE IN_STATE[s6], 02
 01F  35036                JUMP Z, RECDATA[036]
 020  14600                COMPARE IN_STATE[s6], 00
 021  3502A                JUMP Z, FALLINGFLANK[02A]
 022  14601                COMPARE IN_STATE[s6], 01
 023  3502E                JUMP Z, STARTBIT[02E]
 024  14603                COMPARE IN_STATE[s6], 03
 025  35040                JUMP Z, STOPPBIT[040]
 026  1CA01                SUB MOD16_W[sA], 01
 027  2B400                RETURN NZ
 028  00A10                LOAD MOD16_W[sA], 10
 029  2A000                RETURN
 02A                       ; idle, fallende flanke, start bit erkannt wenn nicht abbrechen, daten, stoppbit
 02A                       ; mod 16 für daten
 02A                       ; mod 8 für immer
 02A                       ; --------------------------------------------------------------------------------------------
 02A                       ; Subroutine, die überprüft ob die fallende Flanke nur eine Leitungsstörung
 02A                       ; war, oder ob es sich wirklich um das Startbit handelt.
 02A                       ; Modulo 8 Zähler um in der Mitte der Übertragung nochmal zu überprüfen (16-fache Abtastung).
 02A         FALLINGFLANK: 
 02A  14000                COMPARE IOR[s0], 00
 02B  2B400                RETURN NZ
 02C  18601                ADD IN_STATE[s6], 01
 02D  2A000                RETURN
 02E                       ; --------------------------------------------------------------------------------------------
 02E                       ; Subroutine, die überprüft ob die fallende Flanke nur eine Leitungsstörung
 02E                       ; war, oder ob es sich wirklich um das Startbit handelt.
 02E                       ; Modulo 8 Zähler um in der Mitte der Übertragung nochmal zu überprüfen (16-fache Abtastung).
 02E             STARTBIT: 
 02E  1C401                SUB MOD8[s4], 01
 02F  2B400                RETURN NZ
 030  00408                LOAD MOD8[s4], 08
 031  14000                COMPARE IOR[s0], 00
 032  35456                JUMP NZ, RESET[056]
 033  18601                ADD IN_STATE[s6], 01
 034  00800                LOAD DATA_BUFFER[s8], 00
 035  2A000                RETURN
 036                       ; --------------------------------------------------------------------------------------------
 036                       ; Subroutine, die
 036              RECDATA: 
 036  1C501                SUB MOD16[s5], 01
 037  2B400                RETURN NZ
 038  00510                LOAD MOD16[s5], 10
 039  0D800                OR DATA_BUFFER[s8], IOR[s0]
 03A  2080C                RR DATA_BUFFER[s8]
 03B  1C401                SUB MOD8[s4], 01
 03C  2B400                RETURN NZ
 03D  18601                ADD IN_STATE[s6], 01
 03E  00408                LOAD MOD8[s4], 08
 03F  2A000                RETURN
 040                       ; --------------------------------------------------------------------------------------------
 040                       ; Subroutine,
 040             STOPPBIT: 
 040  1C501                SUB MOD16[s5], 01
 041  2B400                RETURN NZ
 042  00600                LOAD IN_STATE[s6], 00
 043  00510                LOAD MOD16[s5], 10
 044  14001                COMPARE IOR[s0], 01
 045  2B400                RETURN NZ
 046  14830                COMPARE DATA_BUFFER[s8], MIN_NUM[30]
 047  2B800                RETURN C
 048  1483A                COMPARE DATA_BUFFER[s8], MAX_NUM[3A]
 049  35853                JUMP C, WRITE[053]
 04A  1487B                COMPARE DATA_BUFFER[s8], MAX_SA[7B]
 04B  2BC00                RETURN NC
 04C  14841                COMPARE DATA_BUFFER[s8], MIN_BA[41]
 04D  2B800                RETURN C
 04E  1485B                COMPARE DATA_BUFFER[s8], MAX_BA[5B]
 04F  35853                JUMP C, WRITE[053]
 050  14861                COMPARE DATA_BUFFER[s8], MIN_SA[61]
 051  2B800                RETURN C
 052  34053                JUMP WRITE[053]
 053                       ; --------------------------------------------------------------------------------------------
 053                       ; Subroutine, die
 053                WRITE: 
 053  01980                LOAD WRITE_BUFFER[s9], DATA_BUFFER[s8]
 054  00C01                LOAD WRITE_ENABLE[sC], 01
 055  2A000                RETURN
 056                       ; --------------------------------------------------------------------------------------------
 056                RESET: 
 056  00600                LOAD IN_STATE[s6], 00
 057  2A000                RETURN
 058                       ; --------------------------------------------------------------------------------------------
 058                       ; Subroutine, die
 058             COMM_OUT: 
 058  14C01                COMPARE WRITE_ENABLE[sC], 01
 059  2B400                RETURN NZ
 05A  14701                COMPARE OUT_STATE[s7], 01
 05B  35069                JUMP Z, W_DATA[069]
 05C  14700                COMPARE OUT_STATE[s7], 00
 05D  35061                JUMP Z, W_STARTBIT[061]
 05E  14702                COMPARE OUT_STATE[s7], 02
 05F  35072                JUMP Z, W_STOPPBIT[072]
 060  2A000                RETURN
 061                       ; --------------------------------------------------------------------------------------------
 061                       ; Subroutine, die
 061           W_STARTBIT: 
 061  1CA01                SUB MOD16_W[sA], 01
 062  2B400                RETURN NZ
 063  00A10                LOAD MOD16_W[sA], 10
 064  0A000                AND IOR[s0], 00
 065  2C001                OUTPUT IOR[s0], COM_Port[01]
 066  18701                ADD OUT_STATE[s7], 01
 067  00B08                LOAD MOD8_W[sB], 08
 068  2A000                RETURN
 069                       ; --------------------------------------------------------------------------------------------
 069                       ; Subroutine, die
 069               W_DATA: 
 069  1CA01                SUB MOD16_W[sA], 01
 06A  2B400                RETURN NZ
 06B  00A10                LOAD MOD16_W[sA], 10
 06C  2C901                OUTPUT WRITE_BUFFER[s9], COM_Port[01]
 06D  2090C                RR WRITE_BUFFER[s9]
 06E  1CB01                SUB MOD8_W[sB], 01
 06F  2B400                RETURN NZ
 070  18701                ADD OUT_STATE[s7], 01
 071  2A000                RETURN
 072                       ; --------------------------------------------------------------------------------------------
 072                       ; Subroutine, die
 072           W_STOPPBIT: 
 072  1CA01                SUB MOD16_W[sA], 01
 073  2B400                RETURN NZ
 074  00A10                LOAD MOD16_W[sA], 10
 075  00101                LOAD TMP[s1], 01
 076  2C101                OUTPUT TMP[s1], COM_Port[01]
 077  00700                LOAD OUT_STATE[s7], 00
 078  00C00                LOAD WRITE_ENABLE[sC], 00
 079  2A000                RETURN
 07A                       ; --------------------------------------------------------------------------------------------
 300                       ADDRESS 300
 300                       ; Interrupt-Service-Routine
 300  30058           ISR: CALL COMM_OUT[058]
 301  3001D                CALL COMM_IN[01D]
 302  3000D                CALL BNT0LED0[00D]
 303  30016                CALL BLINK[016]
 304  38001                RETURNI ENABLE
 305                       ; --------------------------------------------------------------------------------------------
 305                       ; Interrupt-Vektor
 3FF                       ADDRESS 3FF
 3FF  34300                JUMP ISR[300]

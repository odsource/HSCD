KCPSM3 Assembler log file for program 'programm.psm'.
Generated by KCPSM3 version 1.30
Ken Chapman (Xilinx Ltd) 2005.
02Dec2018-11:39:50

 Addr Code

 000                       CONSTANT IO_Port, 00
 000                       CONSTANT LED0, 01
 000                       CONSTANT LED1, 02
 000                       CONSTANT BNT0, 04
 000                       CONSTANT COM_Port, 01
 000                       CONSTANT TXD, 01
 000                       CONSTANT RXD, 01
 000                       CONSTANT MIN_NUM, 30
 000                       CONSTANT MAX_NUM, 3A
 000                       CONSTANT MIN_BA, 41
 000                       CONSTANT MAX_BA, 5B
 000                       CONSTANT MIN_SA, 61
 000                       CONSTANT MAX_SA, 7B
 000                       ; Register Mapping
 000                       ; alle acht Register s0 bis sF stehen der ISR zur Verfuegung
 000                       NAMEREG s0, IOR
 000                       NAMEREG s1, TMP
 000                       NAMEREG s2, CNTH
 000                       NAMEREG s3, CNTL
 000                       NAMEREG s4, MOD8
 000                       NAMEREG s5, MOD16
 000                       NAMEREG s6, IN_STATE
 000                       NAMEREG s7, OUT_STATE
 000                       NAMEREG s8, DATA_BUFFER
 000                       NAMEREG s9, WRITE_BUFFER
 000                       NAMEREG sA, MOD16_W
 000                       NAMEREG sB, MOD8_W
 000                       NAMEREG sC, WRITE_ENABLE
 000                       ; --------------------------------------------------------------------------------------------
 000                       ADDRESS 000
 000                       ; Hauptfunktion
 000  0A200         start: AND CNTH[s2], 00                       ; Initialisierung des Zaehlers ...
 001  0A300                AND CNTL[s3], 00                       ; in der ISR
 002  00600                LOAD IN_STATE[s6], 00
 003  00700                LOAD OUT_STATE[s7], 00
 004  00408                LOAD MOD8[s4], 08                      ; Initialisierung des modulo 8 Zaehlers
 005  00510                LOAD MOD16[s5], 10                     ; Initialisierung des modulo 8 Zaehlers
 006  00A10                LOAD MOD16_W[sA], 10
 007  00B08                LOAD MOD8_W[sB], 08
 008  00800                LOAD DATA_BUFFER[s8], 00
 009  00900                LOAD WRITE_BUFFER[s9], 00
 00A  00C00                LOAD WRITE_ENABLE[sC], 00
 00B  3C001                ENABLE INTERRUPT
 00C                 loop: ; do nothing
 00C  3400C                JUMP loop[00C]
 00D                       ; --------------------------------------------------------------------------------------------
 00D                       ; Subroutine, die den Zustand des Buttons BTN0 auf die Leuchtdiode LED0 durchschaltet
 00D             BNT0LED0: 
 00D  04000                INPUT IOR[s0], IO_Port[00]             ; IO-Port einlesen
 00E  04100                INPUT TMP[s1], IO_Port[00]             ; IO-Port einlesen
 00F  0A104                AND TMP[s1], BNT0[04]                  ; Zustand von BNT0 ermitteln
 010  2010E                SR0 TMP[s1]                            ; auf die Position ...
 011  2010E                SR0 TMP[s1]                            ; ... von LED0 verschieben
 012  0A002                AND IOR[s0], LED1[02]                  ; Zustand von LED1 ermitteln
 013  0D010                OR IOR[s0], TMP[s1]                    ; LED1 mit BNT0 konkatinieren
 014  2C000                OUTPUT IOR[s0], IO_Port[00]            ; den neuen Wert ueber IO-Port ausgeben
 015  2A000                RETURN
 016                       ; --------------------------------------------------------------------------------------------
 016                       ; Subroutine, die die Leuchtdione LED1 mit ca. 1 Hz blinken laesst
 016  18301         BLINK: ADD CNTL[s3], 01                       ; den 16-Bit-Zaehler ...
 017  1A200                ADDCY CNTH[s2], 00                     ; .. inkrementieren
 018  35C1C                JUMP NC, BLINK0[01C]                   ; kein Ueberlauf -> exit, sonst
 019  04000                INPUT IOR[s0], IO_Port[00]             ; IO-Port einlesen
 01A  0E002                XOR IOR[s0], LED1[02]                  ; LED1 toggeln
 01B  2C000                OUTPUT IOR[s0], IO_Port[00]            ; den neuen Wert ueber IO-Port ausgeben
 01C  2A000        BLINK0: RETURN
 01D                       ; --------------------------------------------------------------------------------------------
 01D                       ; Subroutine, die Daten ueber das serielle Eingangssignal RXD abtastet,
 01D                       ; zu einem Byte zusammensetzt, entscheidet, ob das empfangene Byte
 01D                       ; ein Buchstabe oder eine Ziffer ist, und ggf. das Byte seriell
 01D                       ; ueber das serielle Ausgangssignal TXD ausgibt
 01D                       ;
 01D                       ; in dieser Version ist eine einfache Echo-Funktion implementiert
 01D              COMM_IN: 
 01D  14602                COMPARE IN_STATE[s6], 02
 01E  35036                JUMP Z, RECDATA[036]
 01F  14600                COMPARE IN_STATE[s6], 00
 020  35029                JUMP Z, FALLINGFLANK[029]
 021  14601                COMPARE IN_STATE[s6], 01
 022  3502E                JUMP Z, STARTBIT[02E]
 023  14603                COMPARE IN_STATE[s6], 03
 024  35040                JUMP Z, STOPPBIT[040]
 025  1CA01                SUB MOD16_W[sA], 01
 026  2B400                RETURN NZ
 027  00A10                LOAD MOD16_W[sA], 10
 028  2A000                RETURN
 029                       ; idle, fallende flanke, start bit erkannt wenn nicht abbrechen, daten, stoppbit
 029                       ; mod 16 für daten
 029                       ; mod 8 für immer
 029                       ; --------------------------------------------------------------------------------------------
 029                       ; Subroutine, die überprüft ob die fallende Flanke nur eine Leitungsstörung
 029                       ; war, oder ob es sich wirklich um das Startbit handelt.
 029                       ; Modulo 8 Zähler um in der Mitte der Übertragung nochmal zu überprüfen (16-fache Abtastung).
 029         FALLINGFLANK: 
 029  04001                INPUT IOR[s0], COM_Port[01]            ; COM_Port einlesen
 02A  14000                COMPARE IOR[s0], 00
 02B  2B400                RETURN NZ
 02C  18601                ADD IN_STATE[s6], 01
 02D  2A000                RETURN
 02E                       ; --------------------------------------------------------------------------------------------
 02E                       ; Subroutine, die überprüft ob die fallende Flanke nur eine Leitungsstörung
 02E                       ; war, oder ob es sich wirklich um das Startbit handelt.
 02E                       ; Modulo 8 Zähler um in der Mitte der Übertragung nochmal zu überprüfen (16-fache Abtastung).
 02E             STARTBIT: 
 02E  2040C                RR MOD8[s4]
 02F  2BC00                RETURN NC
 030  04001                INPUT IOR[s0], COM_Port[01]            ; COM_Port einlesen
 031  14000                COMPARE IOR[s0], 00
 032  2B400                RETURN NZ
 033  00602                LOAD IN_STATE[s6], 02
 034  00800                LOAD DATA_BUFFER[s8], 00
 035  2A000                RETURN
 036                       ; --------------------------------------------------------------------------------------------
 036                       ; Subroutine, die
 036              RECDATA: 
 036  1C501                SUB MOD16[s5], 01
 037  2B400                RETURN NZ
 038  00510                LOAD MOD16[s5], 10
 039  04001                INPUT IOR[s0], COM_Port[01]            ; COM_Port einlesen
 03A  0D800                OR DATA_BUFFER[s8], IOR[s0]
 03B  2080C                RR DATA_BUFFER[s8]
 03C  2040C                RR MOD8[s4]
 03D  2BC00                RETURN NC
 03E  18601                ADD IN_STATE[s6], 01
 03F  2A000                RETURN
 040                       ; --------------------------------------------------------------------------------------------
 040                       ; Subroutine,
 040             STOPPBIT: 
 040  1C501                SUB MOD16[s5], 01
 041  2B400                RETURN NZ
 042  00600                LOAD IN_STATE[s6], 00
 043  00510                LOAD MOD16[s5], 10
 044  04001                INPUT IOR[s0], COM_Port[01]            ; COM_Port einlesen
 045  14001                COMPARE IOR[s0], 01
 046  2B400                RETURN NZ
 047  14830                COMPARE DATA_BUFFER[s8], MIN_NUM[30]
 048  2B800                RETURN C
 049  1483A                COMPARE DATA_BUFFER[s8], MAX_NUM[3A]
 04A  35854                JUMP C, WRITE[054]
 04B  1487B                COMPARE DATA_BUFFER[s8], MAX_SA[7B]
 04C  2BC00                RETURN NC
 04D  14841                COMPARE DATA_BUFFER[s8], MIN_BA[41]
 04E  2B800                RETURN C
 04F  1485B                COMPARE DATA_BUFFER[s8], MAX_BA[5B]
 050  35854                JUMP C, WRITE[054]
 051  14861                COMPARE DATA_BUFFER[s8], MIN_SA[61]
 052  2B800                RETURN C
 053  34054                JUMP WRITE[054]
 054                       ; --------------------------------------------------------------------------------------------
 054                       ; Subroutine, die
 054                WRITE: 
 054  01980                LOAD WRITE_BUFFER[s9], DATA_BUFFER[s8]
 055  00C01                LOAD WRITE_ENABLE[sC], 01
 056  2A000                RETURN
 057                       ; --------------------------------------------------------------------------------------------
 057                       ; Subroutine, die
 057             COMM_OUT: 
 057  14C01                COMPARE WRITE_ENABLE[sC], 01
 058  2B400                RETURN NZ
 059  14701                COMPARE OUT_STATE[s7], 01
 05A  35067                JUMP Z, W_DATA[067]
 05B  14700                COMPARE OUT_STATE[s7], 00
 05C  35060                JUMP Z, W_STARTBIT[060]
 05D  14702                COMPARE OUT_STATE[s7], 02
 05E  35071                JUMP Z, W_STOPPBIT[071]
 05F  2A000                RETURN
 060                       ; --------------------------------------------------------------------------------------------
 060                       ; Subroutine, die
 060           W_STARTBIT: 
 060  1CA01                SUB MOD16_W[sA], 01
 061  2B400                RETURN NZ
 062  00A10                LOAD MOD16_W[sA], 10
 063  0A000                AND IOR[s0], 00
 064  2C001                OUTPUT IOR[s0], COM_Port[01]
 065  18701                ADD OUT_STATE[s7], 01
 066  2A000                RETURN
 067                       ; --------------------------------------------------------------------------------------------
 067                       ; Subroutine, die
 067               W_DATA: 
 067  1CA01                SUB MOD16_W[sA], 01
 068  2B400                RETURN NZ
 069  00A10                LOAD MOD16_W[sA], 10
 06A  2C901                OUTPUT WRITE_BUFFER[s9], COM_Port[01]
 06B  2090C                RR WRITE_BUFFER[s9]
 06C  1CB01                SUB MOD8_W[sB], 01
 06D  2B400                RETURN NZ
 06E  00B08                LOAD MOD8_W[sB], 08
 06F  18701                ADD OUT_STATE[s7], 01
 070  2A000                RETURN
 071                       ; --------------------------------------------------------------------------------------------
 071                       ; Subroutine, die
 071           W_STOPPBIT: 
 071  1CA01                SUB MOD16_W[sA], 01
 072  2B400                RETURN NZ
 073  00A10                LOAD MOD16_W[sA], 10
 074  00101                LOAD TMP[s1], 01
 075  2C101                OUTPUT TMP[s1], COM_Port[01]
 076  00700                LOAD OUT_STATE[s7], 00
 077  00C00                LOAD WRITE_ENABLE[sC], 00
 078  2A000                RETURN
 079                       ; --------------------------------------------------------------------------------------------
 300                       ADDRESS 300
 300                       ; Interrupt-Service-Routine
 300  30057           ISR: CALL COMM_OUT[057]
 301  3001D                CALL COMM_IN[01D]
 302  3000D                CALL BNT0LED0[00D]
 303  30016                CALL BLINK[016]
 304  38001                RETURNI ENABLE
 305                       ; --------------------------------------------------------------------------------------------
 305                       ; Interrupt-Vektor
 3FF                       ADDRESS 3FF
 3FF  34300                JUMP ISR[300]

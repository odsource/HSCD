KCPSM3 Assembler log file for program 'programm.psm'.
Generated by KCPSM3 version 1.30
Ken Chapman (Xilinx Ltd) 2005.
11Nov2018-22:13:29

 Addr Code

 000                       CONSTANT IO_Port, 00
 000                       CONSTANT LED0, 01
 000                       CONSTANT LED1, 02
 000                       CONSTANT BNT0, 04
 000                       CONSTANT COM_Port, 01
 000                       CONSTANT TXD, 01
 000                       CONSTANT RXD, 01
 000                       ; Register Mapping
 000                       ; alle acht Register s0 bis sF stehen der ISR zur Verfuegung
 000                       NAMEREG s0, IOR
 000                       NAMEREG s1, TMP
 000                       NAMEREG s2, CNTH
 000                       NAMEREG s3, CNTL
 000                       NAMEREG s4, MOD8
 000                       NAMEREG s5, MOD16
 000                       NAMEREG s6, STATE
 000                       NAMEREG s7, DATA
 000                       ; --------------------------------------------------------------------------------------------
 000                       ADDRESS 000
 000                       ; Hauptfunktion
 000  0A200         start: AND CNTH[s2], 00             ; Initialisierung der Zaehlers ...
 001  0A300                AND CNTL[s3], 00             ; in der ISR
 002  0A600                AND STATE[s6], 00
 003  0A400                AND MOD8[s4], 00             ; Initialisierung des modulo 8 Zaehlers in der ISR
 004  3C001                ENABLE INTERRUPT
 005                 loop: ; do nothing
 005  34005                JUMP loop[005]
 006                       ; --------------------------------------------------------------------------------------------
 006                       ; Subroutine, die den Zustand des Buttons BTN0 auf die Leuchtdiode LED0 durchschaltet
 006             BNT0LED0: 
 006  04000                INPUT IOR[s0], IO_Port[00]   ; IO-Port einlesen
 007  04100                INPUT TMP[s1], IO_Port[00]   ; IO-Port einlesen
 008  0A104                AND TMP[s1], BNT0[04]        ; Zustand von BNT0 ermitteln
 009  2010E                SR0 TMP[s1]                  ; auf die Position ...
 00A  2010E                SR0 TMP[s1]                  ; ... von LED0 verschieben
 00B  0A002                AND IOR[s0], LED1[02]        ; Zustand von LED1 ermitteln
 00C  0D010                OR IOR[s0], TMP[s1]          ; LED1 mit BNT0 konkatinieren
 00D  2C000                OUTPUT IOR[s0], IO_Port[00]  ; den neuen Wert ueber IO-Port ausgeben
 00E  2A000                RETURN
 00F                       ; --------------------------------------------------------------------------------------------
 00F                       ; Subroutine, die die Leuchtdione LED1 mit ca. 1 Hz blinken laesst
 00F  18301         BLINK: ADD CNTL[s3], 01             ; den 16-Bit-Zaehler ...
 010  1A200                ADDCY CNTH[s2], 00           ; .. inkrementieren
 011  35C15                JUMP NC, BLINK0[015]         ; kein Ueberlauf -> exit, sonst
 012  04000                INPUT IOR[s0], IO_Port[00]   ; IO-Port einlesen
 013  0E002                XOR IOR[s0], LED1[02]        ; LED1 toggeln
 014  2C000                OUTPUT IOR[s0], IO_Port[00]  ; den neuen Wert ueber IO-Port ausgeben
 015  2A000        BLINK0: RETURN
 016                       ; --------------------------------------------------------------------------------------------
 016                       ; Subroutine, die Daten ueber das serielle Eingangssignal RXD abtastet,
 016                       ; zu einem Byte zusammensetzt, entscheidet, ob das empfangene Byte
 016                       ; ein Buchstabe oder eine Ziffer ist, und ggf. das Byte seriell
 016                       ; ueber das serielle Ausgangssignal TXD ausgibt
 016                       ;
 016                       ; in dieser Version ist eine einfache Echo-Funktion implementiert
 016                 COMM: 
 016  04001                INPUT IOR[s0], COM_Port[01]  ; COM-Port einlesen
 017                       ;       AND     IOR,   RXD      ; Zustand von RXD ermitteln
 017  00408                LOAD MOD8[s4], 08            ; Modulo 8 Zaehler initialisieren
 018  005FF                LOAD MOD16[s5], FF           ; Modulo 16 Zaehler initialisieren
 019  14000                COMPARE IOR[s0], 00
 01A  35416                JUMP NZ, COMM[016]
 01B  14600                COMPARE STATE[s6], 00
 01C  35023                JUMP Z, FALLINGFLANK[023]
 01D  14601                COMPARE STATE[s6], 01
 01E  35029                JUMP Z, START[029]
 01F  14602                COMPARE STATE[s6], 02
 020  35031                JUMP Z, STOPPBIT[031]
 021  2C001                OUTPUT IOR[s0], COM_Port[01] ; TXD ausgeben
 022  2A000                RETURN
 023                       ; idle, fallende flanke, start bit erkannt wenn nicht abbrechen, daten, stoppbit
 023                       ; mod 16 für daten
 023                       ; mod 8 für immer
 023                       ; --------------------------------------------------------------------------------------------
 023                       ; Subroutine, die überprüft ob die fallende Flanke nur eine Leitungsstörung
 023                       ; war, oder ob es sich wirklich um das Startbit handelt.
 023                       ; Modulo 8 Zähler um in der Mitte der Übertragung nochmal zu überprüfen (16-fache Abtastung).
 023         FALLINGFLANK: 
 023  1C401                SUB MOD8[s4], 01
 024  35423                JUMP NZ, FALLINGFLANK[023]
 025  15040                COMPARE IOR[s0], MOD8[s4]
 026  2B400                RETURN NZ
 027  18601                ADD STATE[s6], 01
 028  00408                LOAD MOD8[s4], 08
 029                       ; --------------------------------------------------------------------------------------------
 029                       ; Subroutine, die
 029                START: 
 029  1C501                SUB MOD16[s5], 01
 02A  35429                JUMP NZ, START[029]
 02B  2070E                SR0 DATA[s7]
 02C  2F070                STORE IOR[s0], (DATA)[(s7)]
 02D  1C401                SUB MOD8[s4], 01
 02E  35429                JUMP NZ, START[029]
 02F  18601                ADD STATE[s6], 01
 030  00408                LOAD MOD8[s4], 08
 031                       ; --------------------------------------------------------------------------------------------
 031                       ; Subroutine,
 031             STOPPBIT: 
 031  1C401                SUB MOD8[s4], 01
 032  35431                JUMP NZ, STOPPBIT[031]
 033  14001                COMPARE IOR[s0], 01
 034                       ; --------------------------------------------------------------------------------------------
 300                       ADDRESS 300
 300                       ; Interrupt-Service-Routine
 300  30006           ISR: CALL BNT0LED0[006]
 301  3000F                CALL BLINK[00F]
 302  30016                CALL COMM[016]
 303  38001                RETURNI ENABLE
 304                       ; --------------------------------------------------------------------------------------------
 304                       ; Interrupt-Vektor
 3FF                       ADDRESS 3FF
 3FF  34300                JUMP ISR[300]

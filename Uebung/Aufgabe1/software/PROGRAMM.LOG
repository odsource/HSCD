KCPSM3 Assembler log file for program 'programm.psm'.
Generated by KCPSM3 version 1.30
Ken Chapman (Xilinx Ltd) 2005.
02Dec2018-11:48:51

 Addr Code

 000                       CONSTANT IO_Port, 00
 000                       CONSTANT LED0, 01
 000                       CONSTANT LED1, 02
 000                       CONSTANT BNT0, 04
 000                       CONSTANT COM_Port, 01
 000                       CONSTANT TXD, 01
 000                       CONSTANT RXD, 01
 000                       CONSTANT MIN_NUM, 30
 000                       CONSTANT MAX_NUM, 3A
 000                       CONSTANT MIN_BA, 41
 000                       CONSTANT MAX_BA, 5B
 000                       CONSTANT MIN_SA, 61
 000                       CONSTANT MAX_SA, 7B
 000                       ; Register Mapping
 000                       ; alle acht Register s0 bis sF stehen der ISR zur Verfuegung
 000                       NAMEREG s0, IOR
 000                       NAMEREG s1, TMP
 000                       NAMEREG s2, CNTH
 000                       NAMEREG s3, CNTL
 000                       NAMEREG s4, MOD8
 000                       NAMEREG s5, MOD16
 000                       NAMEREG s6, IN_STATE
 000                       NAMEREG s7, OUT_STATE
 000                       NAMEREG s8, DATA_BUFFER
 000                       NAMEREG s9, WRITE_BUFFER
 000                       NAMEREG sA, MOD16_W
 000                       NAMEREG sB, MOD8_W
 000                       NAMEREG sC, WRITE_ENABLE
 000                       ; --------------------------------------------------------------------------------------------
 000                       ADDRESS 000
 000                       ; Hauptfunktion
 000  0A200         start: AND CNTH[s2], 00                       ; Initialisierung des Zaehlers ...
 001  0A300                AND CNTL[s3], 00                       ; in der ISR
 002  00600                LOAD IN_STATE[s6], 00
 003  00700                LOAD OUT_STATE[s7], 00
 004  00408                LOAD MOD8[s4], 08                      ; Initialisierung des modulo 8 Zaehlers
 005  00510                LOAD MOD16[s5], 10                     ; Initialisierung des modulo 8 Zaehlers
 006  00A10                LOAD MOD16_W[sA], 10
 007  00B08                LOAD MOD8_W[sB], 08
 008  00800                LOAD DATA_BUFFER[s8], 00
 009  00900                LOAD WRITE_BUFFER[s9], 00
 00A  00C00                LOAD WRITE_ENABLE[sC], 00
 00B  3C001                ENABLE INTERRUPT
 00C                 loop: ; do nothing
 00C  3400C                JUMP loop[00C]
 00D                       ; --------------------------------------------------------------------------------------------
 00D                       ; Subroutine, die den Zustand des Buttons BTN0 auf die Leuchtdiode LED0 durchschaltet
 00D             BNT0LED0: 
 00D  04000                INPUT IOR[s0], IO_Port[00]             ; IO-Port einlesen
 00E  04100                INPUT TMP[s1], IO_Port[00]             ; IO-Port einlesen
 00F  0A104                AND TMP[s1], BNT0[04]                  ; Zustand von BNT0 ermitteln
 010  2010E                SR0 TMP[s1]                            ; auf die Position ...
 011  2010E                SR0 TMP[s1]                            ; ... von LED0 verschieben
 012  0A002                AND IOR[s0], LED1[02]                  ; Zustand von LED1 ermitteln
 013  0D010                OR IOR[s0], TMP[s1]                    ; LED1 mit BNT0 konkatinieren
 014  2C000                OUTPUT IOR[s0], IO_Port[00]            ; den neuen Wert ueber IO-Port ausgeben
 015  2A000                RETURN
 016                       ; --------------------------------------------------------------------------------------------
 016                       ; Subroutine, die die Leuchtdione LED1 mit ca. 1 Hz blinken laesst
 016  18301         BLINK: ADD CNTL[s3], 01                       ; den 16-Bit-Zaehler ...
 017  1A200                ADDCY CNTH[s2], 00                     ; .. inkrementieren
 018  35C1C                JUMP NC, BLINK0[01C]                   ; kein Ueberlauf -> exit, sonst
 019  04000                INPUT IOR[s0], IO_Port[00]             ; IO-Port einlesen
 01A  0E002                XOR IOR[s0], LED1[02]                  ; LED1 toggeln
 01B  2C000                OUTPUT IOR[s0], IO_Port[00]            ; den neuen Wert ueber IO-Port ausgeben
 01C  2A000        BLINK0: RETURN
 01D                       ; --------------------------------------------------------------------------------------------
 01D                       ; Subroutine, die Daten ueber das serielle Eingangssignal RXD abtastet,
 01D                       ; zu einem Byte zusammensetzt, entscheidet, ob das empfangene Byte
 01D                       ; ein Buchstabe oder eine Ziffer ist, und ggf. das Byte seriell
 01D                       ; ueber das serielle Ausgangssignal TXD ausgibt
 01D                       ;
 01D                       ; in dieser Version ist eine einfache Echo-Funktion implementiert
 01D              COMM_IN: 
 01D  14602                COMPARE IN_STATE[s6], 02
 01E  35037                JUMP Z, RECDATA[037]
 01F  14600                COMPARE IN_STATE[s6], 00
 020  35029                JUMP Z, FALLINGFLANK[029]
 021  14601                COMPARE IN_STATE[s6], 01
 022  3502E                JUMP Z, STARTBIT[02E]
 023  14603                COMPARE IN_STATE[s6], 03
 024  35042                JUMP Z, STOPPBIT[042]
 025  1CA01                SUB MOD16_W[sA], 01
 026  2B400                RETURN NZ
 027  00A10                LOAD MOD16_W[sA], 10
 028  2A000                RETURN
 029                       ; idle, fallende flanke, start bit erkannt wenn nicht abbrechen, daten, stoppbit
 029                       ; mod 16 für daten
 029                       ; mod 8 für immer
 029                       ; --------------------------------------------------------------------------------------------
 029                       ; Subroutine, die überprüft ob die fallende Flanke nur eine Leitungsstörung
 029                       ; war, oder ob es sich wirklich um das Startbit handelt.
 029                       ; Modulo 8 Zähler um in der Mitte der Übertragung nochmal zu überprüfen (16-fache Abtastung).
 029         FALLINGFLANK: 
 029  04001                INPUT IOR[s0], COM_Port[01]            ; COM_Port einlesen
 02A  14000                COMPARE IOR[s0], 00
 02B  2B400                RETURN NZ
 02C  18601                ADD IN_STATE[s6], 01
 02D  2A000                RETURN
 02E                       ; --------------------------------------------------------------------------------------------
 02E                       ; Subroutine, die überprüft ob die fallende Flanke nur eine Leitungsstörung
 02E                       ; war, oder ob es sich wirklich um das Startbit handelt.
 02E                       ; Modulo 8 Zähler um in der Mitte der Übertragung nochmal zu überprüfen (16-fache Abtastung).
 02E             STARTBIT: 
 02E  1C401                SUB MOD8[s4], 01
 02F  2B400                RETURN NZ
 030  00408                LOAD MOD8[s4], 08
 031  04001                INPUT IOR[s0], COM_Port[01]            ; COM_Port einlesen
 032  14000                COMPARE IOR[s0], 00
 033  2B400                RETURN NZ
 034  00602                LOAD IN_STATE[s6], 02
 035  00800                LOAD DATA_BUFFER[s8], 00
 036  2A000                RETURN
 037                       ; --------------------------------------------------------------------------------------------
 037                       ; Subroutine, die
 037              RECDATA: 
 037  1C501                SUB MOD16[s5], 01
 038  2B400                RETURN NZ
 039  00510                LOAD MOD16[s5], 10
 03A  04001                INPUT IOR[s0], COM_Port[01]            ; COM_Port einlesen
 03B  0D800                OR DATA_BUFFER[s8], IOR[s0]
 03C  2080C                RR DATA_BUFFER[s8]
 03D  1C401                SUB MOD8[s4], 01
 03E  2B400                RETURN NZ
 03F  00408                LOAD MOD8[s4], 08
 040  18601                ADD IN_STATE[s6], 01
 041  2A000                RETURN
 042                       ; --------------------------------------------------------------------------------------------
 042                       ; Subroutine,
 042             STOPPBIT: 
 042  1C501                SUB MOD16[s5], 01
 043  2B400                RETURN NZ
 044  00600                LOAD IN_STATE[s6], 00
 045  00510                LOAD MOD16[s5], 10
 046  04001                INPUT IOR[s0], COM_Port[01]            ; COM_Port einlesen
 047  14001                COMPARE IOR[s0], 01
 048  2B400                RETURN NZ
 049  1487B                COMPARE DATA_BUFFER[s8], MAX_SA[7B]    ; Hex 7B
 04A  2BC00                RETURN NC
 04B  14830                COMPARE DATA_BUFFER[s8], MIN_NUM[30]   ; Hex 30
 04C  2B800                RETURN C
 04D  14861                COMPARE DATA_BUFFER[s8], MIN_SA[61]    ; Hex 61
 04E  35C56                JUMP NC, WRITE[056]
 04F  1485B                COMPARE DATA_BUFFER[s8], MAX_BA[5B]    ; Hex 5B
 050  2BC00                RETURN NC
 051  14841                COMPARE DATA_BUFFER[s8], MIN_BA[41]    ; Hex 41
 052  35C56                JUMP NC, WRITE[056]
 053  1483A                COMPARE DATA_BUFFER[s8], MAX_NUM[3A]   ; Hex 3A
 054  35856                JUMP C, WRITE[056]
 055  2A000                RETURN
 056                       ; --------------------------------------------------------------------------------------------
 056                       ; Subroutine, die
 056                WRITE: 
 056  01980                LOAD WRITE_BUFFER[s9], DATA_BUFFER[s8]
 057  00C01                LOAD WRITE_ENABLE[sC], 01
 058  2A000                RETURN
 059                       ; --------------------------------------------------------------------------------------------
 059                       ; Subroutine, die
 059             COMM_OUT: 
 059  14C01                COMPARE WRITE_ENABLE[sC], 01
 05A  2B400                RETURN NZ
 05B  14701                COMPARE OUT_STATE[s7], 01
 05C  35069                JUMP Z, W_DATA[069]
 05D  14700                COMPARE OUT_STATE[s7], 00
 05E  35062                JUMP Z, W_STARTBIT[062]
 05F  14702                COMPARE OUT_STATE[s7], 02
 060  35073                JUMP Z, W_STOPPBIT[073]
 061  2A000                RETURN
 062                       ; --------------------------------------------------------------------------------------------
 062                       ; Subroutine, die
 062           W_STARTBIT: 
 062  1CA01                SUB MOD16_W[sA], 01
 063  2B400                RETURN NZ
 064  00A10                LOAD MOD16_W[sA], 10
 065  0A000                AND IOR[s0], 00
 066  2C001                OUTPUT IOR[s0], COM_Port[01]
 067  18701                ADD OUT_STATE[s7], 01
 068  2A000                RETURN
 069                       ; --------------------------------------------------------------------------------------------
 069                       ; Subroutine, die
 069               W_DATA: 
 069  1CA01                SUB MOD16_W[sA], 01
 06A  2B400                RETURN NZ
 06B  00A10                LOAD MOD16_W[sA], 10
 06C  2C901                OUTPUT WRITE_BUFFER[s9], COM_Port[01]
 06D  2090C                RR WRITE_BUFFER[s9]
 06E  1CB01                SUB MOD8_W[sB], 01
 06F  2B400                RETURN NZ
 070  00B08                LOAD MOD8_W[sB], 08
 071  18701                ADD OUT_STATE[s7], 01
 072  2A000                RETURN
 073                       ; --------------------------------------------------------------------------------------------
 073                       ; Subroutine, die
 073           W_STOPPBIT: 
 073  1CA01                SUB MOD16_W[sA], 01
 074  2B400                RETURN NZ
 075  00A10                LOAD MOD16_W[sA], 10
 076  00101                LOAD TMP[s1], 01
 077  2C101                OUTPUT TMP[s1], COM_Port[01]
 078  00700                LOAD OUT_STATE[s7], 00
 079  00C00                LOAD WRITE_ENABLE[sC], 00
 07A  2A000                RETURN
 07B                       ; --------------------------------------------------------------------------------------------
 300                       ADDRESS 300
 300                       ; Interrupt-Service-Routine
 300  30059           ISR: CALL COMM_OUT[059]
 301  3001D                CALL COMM_IN[01D]
 302  3000D                CALL BNT0LED0[00D]
 303  30016                CALL BLINK[016]
 304  38001                RETURNI ENABLE
 305                       ; --------------------------------------------------------------------------------------------
 305                       ; Interrupt-Vektor
 3FF                       ADDRESS 3FF
 3FF  34300                JUMP ISR[300]

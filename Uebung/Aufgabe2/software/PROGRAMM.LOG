KCPSM3 Assembler log file for program 'programm.psm'.
Generated by KCPSM3 version 1.30
Ken Chapman (Xilinx Ltd) 2005.
03Dec2018-17:59:26

 Addr Code

 000                       CONSTANT IO_Port, 00
 000                       CONSTANT LED0, 01
 000                       CONSTANT LED1, 02
 000                       CONSTANT BNT0, 04
 000                       CONSTANT COM_Port, 01
 000                       CONSTANT TXD, 01
 000                       CONSTANT RXD, 01
 000                       CONSTANT MIN_NUM, 30
 000                       CONSTANT MAX_NUM, 3A
 000                       CONSTANT MIN_BA, 41
 000                       CONSTANT MAX_BA, 5B
 000                       CONSTANT MIN_SA, 61
 000                       CONSTANT MAX_SA, 7B
 000                       CONSTANT RAM_POINTER, 02
 000                       CONSTANT RAM, 04
 000                       ; Register Mapping
 000                       ; alle acht Register s0 bis sF stehen der ISR zur Verfuegung
 000                       NAMEREG s0, IOR
 000                       NAMEREG s1, TMP
 000                       NAMEREG s2, CNTH
 000                       NAMEREG s3, CNTL
 000                       NAMEREG s4, COUNTER
 000                       NAMEREG s5, STATE
 000                       NAMEREG s6, DATA_BUFFER
 000                       NAMEREG s7, WRITE_ENABLE
 000                       NAMEREG s8, DATA_COUNTER
 000                       NAMEREG s9, RECV_DATA_CNT
 000                       NAMEREG sA, WRITE_ADRESS
 000                       NAMEREG sB, READ_ADRESS
 000                       NAMEREG sC, START
 000                       NAMEREG sD, STOP
 000                       ; --------------------------------------------------------------------------------------------
 000                       ADDRESS 000
 000                       ; Hauptfunktion
 000  0A200         start: AND CNTH[s2], 00                          ; Initialisierung des Zaehlers ...
 001  0A300                AND CNTL[s3], 00                          ; in der ISR
 002  00500                LOAD STATE[s5], 00
 003  00808                LOAD DATA_COUNTER[s8], 08
 004  00700                LOAD WRITE_ENABLE[s7], 00
 005  00A00                LOAD WRITE_ADRESS[sA], 00
 006  00B00                LOAD READ_ADRESS[sB], 00
 007  00C00                LOAD START[sC], 00
 008  00D01                LOAD STOP[sD], 01
 009  00910                LOAD RECV_DATA_CNT[s9], 10
 00A  3C001                ENABLE INTERRUPT
 00B                 loop: ; do nothing
 00B  3400B                JUMP loop[00B]
 00C                       ; --------------------------------------------------------------------------------------------
 00C                       ; Subroutine, die den Zustand des Buttons BTN0 auf die Leuchtdiode LED0 durchschaltet
 00C             BNT0LED0: 
 00C  04000                INPUT IOR[s0], IO_Port[00]                ; IO-Port einlesen
 00D  04100                INPUT TMP[s1], IO_Port[00]                ; IO-Port einlesen
 00E  0A104                AND TMP[s1], BNT0[04]                     ; Zustand von BNT0 ermitteln
 00F  2010E                SR0 TMP[s1]                               ; auf die Position ...
 010  2010E                SR0 TMP[s1]                               ; ... von LED0 verschieben
 011  0A002                AND IOR[s0], LED1[02]                     ; Zustand von LED1 ermitteln
 012  0D010                OR IOR[s0], TMP[s1]                       ; LED1 mit BNT0 konkatinieren
 013  2C000                OUTPUT IOR[s0], IO_Port[00]               ; den neuen Wert ueber IO-Port ausgeben
 014  2A000                RETURN
 015                       ; --------------------------------------------------------------------------------------------
 015                       ; Subroutine, die die Leuchtdione LED1 mit ca. 1 Hz blinken laesst
 015  18301         BLINK: ADD CNTL[s3], 01                          ; den 16-Bit-Zaehler ...
 016  1A200                ADDCY CNTH[s2], 00                        ; .. inkrementieren
 017  35C1B                JUMP NC, BLINK0[01B]                      ; kein Ueberlauf -> exit, sonst
 018  04000                INPUT IOR[s0], IO_Port[00]                ; IO-Port einlesen
 019  0E002                XOR IOR[s0], LED1[02]                     ; LED1 toggeln
 01A  2C000                OUTPUT IOR[s0], IO_Port[00]               ; den neuen Wert ueber IO-Port ausgeben
 01B  2A000        BLINK0: RETURN
 01C                       ; --------------------------------------------------------------------------------------------
 01C                       ; Subroutine, die Daten ueber das serielle Eingangssignal RXD abtastet,
 01C                       ; zu einem Byte zusammensetzt, entscheidet, ob das empfangene Byte
 01C                       ; ein Buchstabe oder eine Ziffer ist, und ggf. das Byte seriell
 01C                       ; ueber das serielle Ausgangssignal TXD ausgibt
 01C                       ;
 01C                       ; in dieser Version ist eine einfache Echo-Funktion implementiert
 01C              COMM_IN: 
 01C  14700                COMPARE WRITE_ENABLE[s7], 00
 01D  3545B                JUMP NZ, COMM_OUT[05B]
 01E  14502                COMPARE STATE[s5], 02
 01F  35035                JUMP Z, RECDATA[035]
 020  14500                COMPARE STATE[s5], 00
 021  35026                JUMP Z, FALLINGFLANK[026]
 022  14501                COMPARE STATE[s5], 01
 023  3502C                JUMP Z, STARTBIT[02C]
 024  14503                COMPARE STATE[s5], 03
 025  35040                JUMP Z, STOPPBIT[040]
 026                       ; idle, fallende flanke, start bit erkannt wenn nicht abbrechen, daten, stoppbit
 026                       ; mod 16 für daten
 026                       ; mod 8 für immer
 026                       ; --------------------------------------------------------------------------------------------
 026                       ; Subroutine, die überprüft ob die fallende Flanke nur eine Leitungsstörung
 026                       ; war, oder ob es sich wirklich um das Startbit handelt.
 026                       ; Modulo 8 Zähler um in der Mitte der Übertragung nochmal zu überprüfen (16-fache Abtastung).
 026         FALLINGFLANK: 
 026  04001                INPUT IOR[s0], COM_Port[01]               ; COM_Port einlesen
 027  14000                COMPARE IOR[s0], 00
 028  2B400                RETURN NZ
 029  00501                LOAD STATE[s5], 01
 02A  00407                LOAD COUNTER[s4], 07
 02B  2A000                RETURN
 02C                       ; --------------------------------------------------------------------------------------------
 02C                       ; Subroutine, die überprüft ob die fallende Flanke nur eine Leitungsstörung
 02C                       ; war, oder ob es sich wirklich um das Startbit handelt.
 02C                       ; Modulo 8 Zähler um in der Mitte der Übertragung nochmal zu überprüfen (16-fache Abtastung).
 02C             STARTBIT: 
 02C  1C401                SUB COUNTER[s4], 01
 02D  2B400                RETURN NZ
 02E  00410                LOAD COUNTER[s4], 10
 02F  04001                INPUT IOR[s0], COM_Port[01]               ; COM_Port einlesen
 030  14000                COMPARE IOR[s0], 00
 031  2B400                RETURN NZ
 032  00502                LOAD STATE[s5], 02
 033  00600                LOAD DATA_BUFFER[s6], 00
 034  2A000                RETURN
 035                       ; --------------------------------------------------------------------------------------------
 035                       ; Subroutine, die
 035              RECDATA: 
 035  1C401                SUB COUNTER[s4], 01
 036  2B400                RETURN NZ
 037  00410                LOAD COUNTER[s4], 10
 038  04001                INPUT IOR[s0], COM_Port[01]               ; COM_Port einlesen
 039  0D600                OR DATA_BUFFER[s6], IOR[s0]
 03A  2060C                RR DATA_BUFFER[s6]
 03B  1C801                SUB DATA_COUNTER[s8], 01
 03C  2B400                RETURN NZ
 03D  00808                LOAD DATA_COUNTER[s8], 08
 03E  00503                LOAD STATE[s5], 03
 03F  2A000                RETURN
 040                       ; --------------------------------------------------------------------------------------------
 040                       ; Subroutine,
 040             STOPPBIT: 
 040  1C401                SUB COUNTER[s4], 01
 041  2B400                RETURN NZ
 042  00500                LOAD STATE[s5], 00
 043  04001                INPUT IOR[s0], COM_Port[01]               ; COM_Port einlesen
 044  14001                COMPARE IOR[s0], 01
 045  2B400                RETURN NZ
 046  14630                COMPARE DATA_BUFFER[s6], MIN_NUM[30]      ; Hex 30
 047  35855                JUMP C, RESET[055]
 048  1463A                COMPARE DATA_BUFFER[s6], MAX_NUM[3A]      ; Hex 3A
 049  35852                JUMP C, WRITE[052]
 04A  1467B                COMPARE DATA_BUFFER[s6], MAX_SA[7B]       ; Hex 7B
 04B  35C55                JUMP NC, RESET[055]
 04C  14661                COMPARE DATA_BUFFER[s6], MIN_SA[61]       ; Hex 61
 04D  35C52                JUMP NC, WRITE[052]
 04E  1465B                COMPARE DATA_BUFFER[s6], MAX_BA[5B]       ; Hex 5B
 04F  35C55                JUMP NC, RESET[055]
 050  14641                COMPARE DATA_BUFFER[s6], MIN_BA[41]       ; Hex 41
 051  35C52                JUMP NC, WRITE[052]
 052                       ; --------------------------------------------------------------------------------------------
 052                       ; Subroutine, die
 052                WRITE: 
 052  2CB02                OUTPUT READ_ADRESS[sB], RAM_POINTER[02]
 053  18B01                ADD READ_ADRESS[sB], 01
 054  2C604                OUTPUT DATA_BUFFER[s6], RAM[04]
 055                       ; --------------------------------------------------------------------------------------------
 055                RESET: 
 055  1C901                SUB RECV_DATA_CNT[s9], 01
 056  2B400                RETURN NZ
 057  00701                LOAD WRITE_ENABLE[s7], 01
 058  00505                LOAD STATE[s5], 05
 059  00410                LOAD COUNTER[s4], 10
 05A  2A000                RETURN
 05B                       ; --------------------------------------------------------------------------------------------
 05B                       ; Subroutine, die
 05B             COMM_OUT: 
 05B  14506                COMPARE STATE[s5], 06
 05C  3506C                JUMP Z, W_DATA[06C]
 05D  14505                COMPARE STATE[s5], 05
 05E  35062                JUMP Z, W_STARTBIT[062]
 05F  14507                COMPARE STATE[s5], 07
 060  35075                JUMP Z, W_STOPPBIT[075]
 061  2A000                RETURN
 062                       ; --------------------------------------------------------------------------------------------
 062                       ; Subroutine, die
 062           W_STARTBIT: 
 062  1C401                SUB COUNTER[s4], 01
 063  2B400                RETURN NZ
 064  2CC01                OUTPUT START[sC], COM_Port[01]
 065  00410                LOAD COUNTER[s4], 10
 066  00808                LOAD DATA_COUNTER[s8], 08
 067  2CA02                OUTPUT WRITE_ADRESS[sA], RAM_POINTER[02]
 068  18A01                ADD WRITE_ADRESS[sA], 01
 069  04604                INPUT DATA_BUFFER[s6], RAM[04]
 06A  00506                LOAD STATE[s5], 06
 06B  2A000                RETURN
 06C                       ; --------------------------------------------------------------------------------------------
 06C                       ; Subroutine, die
 06C               W_DATA: 
 06C  1C401                SUB COUNTER[s4], 01
 06D  2B400                RETURN NZ
 06E  00410                LOAD COUNTER[s4], 10
 06F  2C601                OUTPUT DATA_BUFFER[s6], COM_Port[01]
 070  2060C                RR DATA_BUFFER[s6]
 071  1C801                SUB DATA_COUNTER[s8], 01
 072  2B400                RETURN NZ
 073  00507                LOAD STATE[s5], 07
 074  2A000                RETURN
 075                       ; --------------------------------------------------------------------------------------------
 075                       ; Subroutine, die
 075           W_STOPPBIT: 
 075  1C401                SUB COUNTER[s4], 01
 076  2B400                RETURN NZ
 077  2CD01                OUTPUT STOP[sD], COM_Port[01]
 078  00410                LOAD COUNTER[s4], 10
 079  00505                LOAD STATE[s5], 05
 07A  15AB0                COMPARE WRITE_ADRESS[sA], READ_ADRESS[sB]
 07B  2B400                RETURN NZ
 07C  00700                LOAD WRITE_ENABLE[s7], 00
 07D  00808                LOAD DATA_COUNTER[s8], 08
 07E  00500                LOAD STATE[s5], 00
 07F  00910                LOAD RECV_DATA_CNT[s9], 10
 080  2A000                RETURN
 081                       ; --------------------------------------------------------------------------------------------
 300                       ADDRESS 300
 300                       ; Interrupt-Service-Routine
 300  3000C           ISR: CALL BNT0LED0[00C]
 301  30015                CALL BLINK[015]
 302  3001C                CALL COMM_IN[01C]
 303  38001                RETURNI ENABLE
 304                       ; --------------------------------------------------------------------------------------------
 304                       ; Interrupt-Vektor
 3FF                       ADDRESS 3FF
 3FF  34300                JUMP ISR[300]

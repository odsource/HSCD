KCPSM3 Assembler log file for program 'programm.psm'.
Generated by KCPSM3 version 1.30
Ken Chapman (Xilinx Ltd) 2005.
20Jan2019-15:34:33

 Addr Code

 000                       CONSTANT IO_Port, 00
 000                       CONSTANT LED0, 01
 000                       CONSTANT LED1, 02
 000                       CONSTANT BNT0, 04
 000                       CONSTANT COM_Port, 01
 000                       CONSTANT TXD, 01
 000                       CONSTANT RXD, 01
 000                       CONSTANT MIN_NUM, 30
 000                       CONSTANT MAX_NUM, 3A
 000                       CONSTANT MIN_BA, 41
 000                       CONSTANT MAX_BA, 5B
 000                       CONSTANT MIN_SA, 61
 000                       CONSTANT MAX_SA, 7B
 000                       CONSTANT RAM_POINTER, 02
 000                       CONSTANT RAM, 04
 000                       CONSTANT RAM_LENGTH, FF
 000                       CONSTANT CO_STRT, 08
 000                       CONSTANT CO_DONE, 08
 000                       CONSTANT CO_LEN, 0B
 000                       CONSTANT CO_PTR, 09
 000                       CONSTANT CO_PTR2, 0A
 000                       ; Register Mapping
 000                       ; alle acht Register s0 bis sF stehen der ISR zur Verfuegung
 000                       NAMEREG s0, IOR
 000                       NAMEREG s1, TMP
 000                       NAMEREG s2, CNTH
 000                       NAMEREG s3, CNTL
 000                       NAMEREG s4, COUNTER
 000                       NAMEREG s5, STATE
 000                       NAMEREG s6, DATA_BUFFER
 000                       NAMEREG s7, WRITE_ENABLE
 000                       NAMEREG s8, DATA_COUNTER
 000                       NAMEREG s9, RECV_DATA_CNT
 000                       NAMEREG sA, WRITE_ADRESS
 000                       NAMEREG sB, READ_ADRESS
 000                       NAMEREG sC, START
 000                       NAMEREG sD, STOP
 000                       NAMEREG sE, SET_STRT
 000                       NAMEREG sF, DONE
 000                       ; --------------------------------------------------------------------------------------------
 000                       ADDRESS 000
 000                       ; Hauptfunktion
 000  0A200         start: AND CNTH[s2], 00                          ; Initialisierung des Zaehlers ...
 001  0A300                AND CNTL[s3], 00                          ; in der ISR
 002  00500                LOAD STATE[s5], 00
 003  00808                LOAD DATA_COUNTER[s8], 08
 004  00700                LOAD WRITE_ENABLE[s7], 00
 005  00A00                LOAD WRITE_ADRESS[sA], 00
 006  00B00                LOAD READ_ADRESS[sB], 00
 007  00C00                LOAD START[sC], 00
 008  00D01                LOAD STOP[sD], 01
 009  00910                LOAD RECV_DATA_CNT[s9], 10
 00A  00E01                LOAD SET_STRT[sE], 01
 00B  00F00                LOAD DONE[sF], 00
 00C  2CC0A                OUTPUT START[sC], CO_PTR2[0A]
 00D  3C001                ENABLE INTERRUPT
 00E                 loop: ; do nothing
 00E  3400E                JUMP loop[00E]
 00F                       ; --------------------------------------------------------------------------------------------
 00F                       ; Subroutine, die den Zustand des Buttons BTN0 auf die Leuchtdiode LED0 durchschaltet
 00F             BNT0LED0: 
 00F  04000                INPUT IOR[s0], IO_Port[00]                ; IO-Port einlesen
 010  04100                INPUT TMP[s1], IO_Port[00]                ; IO-Port einlesen
 011  0A104                AND TMP[s1], BNT0[04]                     ; Zustand von BNT0 ermitteln
 012  2010E                SR0 TMP[s1]                               ; auf die Position ...
 013  2010E                SR0 TMP[s1]                               ; ... von LED0 verschieben
 014  0A002                AND IOR[s0], LED1[02]                     ; Zustand von LED1 ermitteln
 015  0D010                OR IOR[s0], TMP[s1]                       ; LED1 mit BNT0 konkatinieren
 016  2C000                OUTPUT IOR[s0], IO_Port[00]               ; den neuen Wert ueber IO-Port ausgeben
 017  2A000                RETURN
 018                       ; --------------------------------------------------------------------------------------------
 018                       ; Subroutine, die die Leuchtdione LED1 mit ca. 1 Hz blinken laesst
 018  18301         BLINK: ADD CNTL[s3], 01                          ; den 16-Bit-Zaehler ...
 019  1A200                ADDCY CNTH[s2], 00                        ; .. inkrementieren
 01A  35C1E                JUMP NC, BLINK0[01E]                      ; kein Ueberlauf -> exit, sonst
 01B  04000                INPUT IOR[s0], IO_Port[00]                ; IO-Port einlesen
 01C  0E002                XOR IOR[s0], LED1[02]                     ; LED1 toggeln
 01D  2C000                OUTPUT IOR[s0], IO_Port[00]               ; den neuen Wert ueber IO-Port ausgeben
 01E  2A000        BLINK0: RETURN
 01F                       ; --------------------------------------------------------------------------------------------
 01F                       ; Subroutine, die Daten ueber das serielle Eingangssignal RXD abtastet,
 01F                       ; zu einem Byte zusammensetzt, entscheidet, ob das empfangene Byte
 01F                       ; ein Buchstabe oder eine Ziffer ist, und ggf. das Byte seriell
 01F                       ; ueber das serielle Ausgangssignal TXD ausgibt
 01F                       ;
 01F                       ; in dieser Version ist eine einfache Echo-Funktion implementiert
 01F              COMM_IN: 
 01F  14510                COMPARE STATE[s5], 10
 020  35061                JUMP Z, WAIT_ON_DONE[061]
 021  14700                COMPARE WRITE_ENABLE[s7], 00
 022  35468                JUMP NZ, COMM_OUT[068]
 023  14502                COMPARE STATE[s5], 02
 024  3503A                JUMP Z, RECDATA[03A]
 025  14500                COMPARE STATE[s5], 00
 026  3502B                JUMP Z, FALLINGFLANK[02B]
 027  14501                COMPARE STATE[s5], 01
 028  35031                JUMP Z, STARTBIT[031]
 029  14503                COMPARE STATE[s5], 03
 02A  35045                JUMP Z, STOPPBIT[045]
 02B                       ; idle, fallende flanke, start bit erkannt wenn nicht abbrechen, daten, stoppbit
 02B                       ; mod 16 für daten
 02B                       ; mod 8 für immer
 02B                       ; --------------------------------------------------------------------------------------------
 02B                       ; Subroutine, die überprüft ob die fallende Flanke nur eine Leitungsstörung
 02B                       ; war, oder ob es sich wirklich um das Startbit handelt.
 02B                       ; Modulo 8 Zähler um in der Mitte der Übertragung nochmal zu überprüfen (16-fache Abtastung).
 02B         FALLINGFLANK: 
 02B  04001                INPUT IOR[s0], COM_Port[01]               ; COM_Port einlesen
 02C  14000                COMPARE IOR[s0], 00
 02D  2B400                RETURN NZ
 02E  00501                LOAD STATE[s5], 01
 02F  00407                LOAD COUNTER[s4], 07
 030  2A000                RETURN
 031                       ; --------------------------------------------------------------------------------------------
 031                       ; Subroutine, die überprüft ob die fallende Flanke nur eine Leitungsstörung
 031                       ; war, oder ob es sich wirklich um das Startbit handelt.
 031                       ; Modulo 8 Zähler um in der Mitte der Übertragung nochmal zu überprüfen (16-fache Abtastung).
 031             STARTBIT: 
 031  1C401                SUB COUNTER[s4], 01
 032  2B400                RETURN NZ
 033  004FF                LOAD COUNTER[s4], RAM_LENGTH[FF]
 034  04001                INPUT IOR[s0], COM_Port[01]               ; COM_Port einlesen
 035  14000                COMPARE IOR[s0], 00
 036  2B400                RETURN NZ
 037  00502                LOAD STATE[s5], 02
 038  00600                LOAD DATA_BUFFER[s6], 00
 039  2A000                RETURN
 03A                       ; --------------------------------------------------------------------------------------------
 03A                       ; Subroutine, die
 03A              RECDATA: 
 03A  1C401                SUB COUNTER[s4], 01
 03B  2B400                RETURN NZ
 03C  004FF                LOAD COUNTER[s4], RAM_LENGTH[FF]
 03D  04001                INPUT IOR[s0], COM_Port[01]               ; COM_Port einlesen
 03E  0D600                OR DATA_BUFFER[s6], IOR[s0]
 03F  2060C                RR DATA_BUFFER[s6]
 040  1C801                SUB DATA_COUNTER[s8], 01
 041  2B400                RETURN NZ
 042  00808                LOAD DATA_COUNTER[s8], 08
 043  00503                LOAD STATE[s5], 03
 044  2A000                RETURN
 045                       ; --------------------------------------------------------------------------------------------
 045                       ; Subroutine,
 045             STOPPBIT: 
 045  1C401                SUB COUNTER[s4], 01
 046  2B400                RETURN NZ
 047  00500                LOAD STATE[s5], 00
 048  04001                INPUT IOR[s0], COM_Port[01]               ; COM_Port einlesen
 049  14001                COMPARE IOR[s0], 01
 04A  2B400                RETURN NZ
 04B  14630                COMPARE DATA_BUFFER[s6], MIN_NUM[30]      ; Hex 30
 04C  3585A                JUMP C, RESET[05A]
 04D  1463A                COMPARE DATA_BUFFER[s6], MAX_NUM[3A]      ; Hex 3A
 04E  35857                JUMP C, WRITE[057]
 04F  1467B                COMPARE DATA_BUFFER[s6], MAX_SA[7B]       ; Hex 7B
 050  35C5A                JUMP NC, RESET[05A]
 051  14661                COMPARE DATA_BUFFER[s6], MIN_SA[61]       ; Hex 61
 052  35C57                JUMP NC, WRITE[057]
 053  1465B                COMPARE DATA_BUFFER[s6], MAX_BA[5B]       ; Hex 5B
 054  35C5A                JUMP NC, RESET[05A]
 055  14641                COMPARE DATA_BUFFER[s6], MIN_BA[41]       ; Hex 41
 056  35C57                JUMP NC, WRITE[057]
 057                       ; --------------------------------------------------------------------------------------------
 057                       ; Subroutine, die
 057                WRITE: 
 057  2CB02                OUTPUT READ_ADRESS[sB], RAM_POINTER[02]
 058  18B01                ADD READ_ADRESS[sB], 01
 059  2C604                OUTPUT DATA_BUFFER[s6], RAM[04]
 05A                       ; --------------------------------------------------------------------------------------------
 05A                RESET: 
 05A  1C901                SUB RECV_DATA_CNT[s9], 01
 05B  2B400                RETURN NZ
 05C  2CB0B                OUTPUT READ_ADRESS[sB], CO_LEN[0B]
 05D  2CC09                OUTPUT START[sC], CO_PTR[09]
 05E  2CE08                OUTPUT SET_STRT[sE], CO_STRT[08]
 05F  00510                LOAD STATE[s5], 10
 060  2A000                RETURN
 061                       ; --------------------------------------------------------------------------------------------
 061         WAIT_ON_DONE: 
 061  04F08                INPUT DONE[sF], CO_DONE[08]
 062  14F01                COMPARE DONE[sF], 01
 063  2B400                RETURN NZ
 064  00701                LOAD WRITE_ENABLE[s7], 01
 065  00505                LOAD STATE[s5], 05
 066  00410                LOAD COUNTER[s4], 10
 067  2A000                RETURN
 068                       ; --------------------------------------------------------------------------------------------
 068                       ; Subroutine, die
 068             COMM_OUT: 
 068  14506                COMPARE STATE[s5], 06
 069  35079                JUMP Z, W_DATA[079]
 06A  14505                COMPARE STATE[s5], 05
 06B  3506F                JUMP Z, W_STARTBIT[06F]
 06C  14507                COMPARE STATE[s5], 07
 06D  35082                JUMP Z, W_STOPPBIT[082]
 06E  2A000                RETURN
 06F                       ; --------------------------------------------------------------------------------------------
 06F                       ; Subroutine, die
 06F           W_STARTBIT: 
 06F  1C401                SUB COUNTER[s4], 01
 070  2B400                RETURN NZ
 071  2CC01                OUTPUT START[sC], COM_Port[01]
 072  004FF                LOAD COUNTER[s4], RAM_LENGTH[FF]
 073  00808                LOAD DATA_COUNTER[s8], 08
 074  2CA02                OUTPUT WRITE_ADRESS[sA], RAM_POINTER[02]
 075  18A01                ADD WRITE_ADRESS[sA], 01
 076  04604                INPUT DATA_BUFFER[s6], RAM[04]
 077  00506                LOAD STATE[s5], 06
 078  2A000                RETURN
 079                       ; --------------------------------------------------------------------------------------------
 079                       ; Subroutine, die
 079               W_DATA: 
 079  1C401                SUB COUNTER[s4], 01
 07A  2B400                RETURN NZ
 07B  004FF                LOAD COUNTER[s4], RAM_LENGTH[FF]
 07C  2C601                OUTPUT DATA_BUFFER[s6], COM_Port[01]
 07D  2060C                RR DATA_BUFFER[s6]
 07E  1C801                SUB DATA_COUNTER[s8], 01
 07F  2B400                RETURN NZ
 080  00507                LOAD STATE[s5], 07
 081  2A000                RETURN
 082                       ; --------------------------------------------------------------------------------------------
 082                       ; Subroutine, die
 082           W_STOPPBIT: 
 082  1C401                SUB COUNTER[s4], 01
 083  2B400                RETURN NZ
 084  2CD01                OUTPUT STOP[sD], COM_Port[01]
 085  00410                LOAD COUNTER[s4], 10
 086  00505                LOAD STATE[s5], 05
 087  15BA0                COMPARE READ_ADRESS[sB], WRITE_ADRESS[sA]
 088  2B400                RETURN NZ
 089  00808                LOAD DATA_COUNTER[s8], 08
 08A  00500                LOAD STATE[s5], 00
 08B  00910                LOAD RECV_DATA_CNT[s9], 10
 08C  00700                LOAD WRITE_ENABLE[s7], 00
 08D  2A000                RETURN
 08E                       ; --------------------------------------------------------------------------------------------
 300                       ADDRESS 300
 300                       ; Interrupt-Service-Routine
 300  3000F           ISR: CALL BNT0LED0[00F]
 301  30018                CALL BLINK[018]
 302  3001F                CALL COMM_IN[01F]
 303  38001                RETURNI ENABLE
 304                       ; --------------------------------------------------------------------------------------------
 304                       ; Interrupt-Vektor
 3FF                       ADDRESS 3FF
 3FF  34300                JUMP ISR[300]

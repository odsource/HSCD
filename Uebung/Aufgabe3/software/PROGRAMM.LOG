KCPSM3 Assembler log file for program 'programm.psm'.
Generated by KCPSM3 version 1.30
Ken Chapman (Xilinx Ltd) 2005.
24Jan2019-08:42:05

 Addr Code

 000                              CONSTANT IO_Port, 00
 000                              CONSTANT LED0, 01
 000                              CONSTANT LED1, 02
 000                              CONSTANT BNT0, 04
 000                              CONSTANT COM_Port, 01
 000                              CONSTANT TXD, 01
 000                              CONSTANT RXD, 01
 000                              CONSTANT RAM_ADR, 02                ; Adressbits des RAM Bits 7-0
 000                              CONSTANT RAM_DATA, 04               ; Datenbits 7-0 des RAM
 000                              ; Zusätzliche Schnittstellen für Aufgabe 3:
 000                              CONSTANT STATUS_REG, 08             ; STRT Bit (Write) & DONE Bit (Read)
 000                              CONSTANT PTR, 09                    ; PTR Register Bits 7-0
 000                              CONSTANT PTR2, 0A                   ; PTR Register Bits 10-8
 000                              CONSTANT LEN, 0B                    ; LEN Register (8Bit) für Länge des Datenblocks
 000                              ; -----------------------------------------
 000                              CONSTANT BEGINZAHL, 30              ; ASCII Zeichen 0
 000                              CONSTANT ENDZAHL, 3A                ; ASCII Zeichen 9 + 1
 000                              CONSTANT BEGINGROSS, 41             ; ASCII Zeichen A
 000                              CONSTANT ENDGROSS, 5B               ; ASCII Zeichen Z + 1
 000                              CONSTANT BEGINKLEIN, 61             ; ASCII Zeichen a
 000                              CONSTANT ENDKLEIN, 7B               ; ASCII Zeichen z + 1
 000                              CONSTANT ZERO, 00
 000                              CONSTANT ONE, 01
 000                              CONSTANT SEVEN, 07
 000                              CONSTANT EIGHT, 08
 000                              CONSTANT SIXTEEN, 10
 000                              ; Register Mapping
 000                              ; alle acht Register s0 bis s7 stehen der ISR zur Verfuegung
 000                              NAMEREG s0, IOR
 000                              NAMEREG s1, TMP
 000                              NAMEREG s2, CNTH
 000                              NAMEREG s3, CNTL
 000                              NAMEREG s4, COUNTER                 ; Counter für Comm_in und Comm_out
 000                              NAMEREG s5, DATA                    ; Datenregister für Comm_in und Comm_out
 000                              NAMEREG s6, WRITE                   ; Semaphor für Read/Write aus RAM
 000                              NAMEREG s7, DATA_COUNT              ; Zählt wv Bits eingelesen wurden in Datenregister
 000                              NAMEREG s8, STATE                   ; Zustandsmaschine
 000                              NAMEREG s9, DATABLOCK_COUNTER       ; Größe des Datenblocks
 000                              NAMEREG sA, ADR_W                   ; Adresspointer zum Schreiben auf RAM-Block
 000                              NAMEREG sB, ADR_R                   ; Adresspointer zum Lesen von RAM-Block
 000                              NAMEREG sC, Startbit
 000                              NAMEREG sD, Stopbit
 000                              ; alle acht Register s8 bis sF stehen der Main-Funktion zur Verfuegung
 000                              ; --------------------------------------------------------------------------------------------
 000                              ADDRESS 000
 000                              ; Hauptfunktion
 000  0A200                start: AND CNTH[s2], 00                    ; Initialisierung der Zaehlers ...
 001  0A300                       AND CNTL[s3], 00                    ; in der ISR
 002  00811                       LOAD STATE[s8], 11
 003  00600                       LOAD WRITE[s6], 00                  ; Schreiberlaubnis
 004  00A00                       LOAD ADR_W[sA], 00                  ; Zeiger auf RAM-Block Adresse (00)00
 005  00B00                       LOAD ADR_R[sB], 00                  ; Zeiger auf RAM-Block Adresse (00)00
 006  00C00                       LOAD Startbit[sC], 00
 007  00D01                       LOAD Stopbit[sD], 01
 008  009FF                       LOAD DATABLOCK_COUNTER[s9], FF      ; feste Größe 255
 009  2CA0A                       OUTPUT ADR_W[sA], PTR2[0A]          ; Bits 10-8 des PTR mit 00 initialisieren und unberührt lassen
 00A  3C001                       ENABLE INTERRUPT
 00B                        loop: ; do nothing
 00B  3400B                       JUMP loop[00B]
 00C                              ; --------------------------------------------------------------------------------------------
 00C                              ; Subroutine, die den Zustand des Buttons BTN0 auf die Leuchtdiode LED0 durchschaltet
 00C                    BNT0LED0: 
 00C  04000                       INPUT IOR[s0], IO_Port[00]          ; IO-Port einlesen
 00D  04100                       INPUT TMP[s1], IO_Port[00]          ; IO-Port einlesen
 00E  0A104                       AND TMP[s1], BNT0[04]               ; Zustand von BNT0 ermitteln
 00F  2010E                       SR0 TMP[s1]                         ; auf die Position ...
 010  2010E                       SR0 TMP[s1]                         ; ... von LED0 verschieben
 011  0A002                       AND IOR[s0], LED1[02]               ; Zustand von LED1 ermitteln
 012  0D010                       OR IOR[s0], TMP[s1]                 ; LED1 mit BNT0 konkatinieren
 013  2C000                       OUTPUT IOR[s0], IO_Port[00]         ; den neuen Wert ueber IO-Port ausgeben
 014  2A000                       RETURN
 015                              ; --------------------------------------------------------------------------------------------
 015                              ; Subroutine, die die Leuchtdione LED1 mit ca. 1 Hz blinken laesst
 015  18301                BLINK: ADD CNTL[s3], 01                    ; den 16-Bit-Zaehler ...
 016  1A200                       ADDCY CNTH[s2], 00                  ; .. inkrementieren
 017  35C1B                       JUMP NC, BLINK0[01B]                ; kein Ueberlauf -> exit, sonst
 018  04000                       INPUT IOR[s0], IO_Port[00]          ; IO-Port einlesen
 019  0E002                       XOR IOR[s0], LED1[02]               ; LED1 toggeln
 01A  2C000                       OUTPUT IOR[s0], IO_Port[00]         ; den neuen Wert ueber IO-Port ausgeben
 01B  2A000               BLINK0: RETURN
 01C                              ; --------------------------------------------------------------------------------------------
 01C                              ; Subroutine, die Daten ueber das serielle Eingangssignal RXD abtastet,
 01C                              ; zu einem Byte zusammensetzt, entschidet, ob das empfangene Byte
 01C                              ; ein Buchstabe oder eine Ziffer ist, und ggf. das Byte seriell
 01C                              ; ueber das serielle Ausgangssignal TXD ausgibt
 01C                              ; ------------------- Zustandsautomat zum Festlegen des Lesezustandes ------------------------
 01C                     COMM_IN: 
 01C                              ; Die Zustände sind zirkulär angeordnet und im Regelfall über eine 1-Bit Rotation erreichbar
 01C  14600                       COMPARE WRITE[s6], 00
 01D  3545E                       JUMP NZ, COMM_OUT[05E]              ; Lesen nicht erlaubt wenn WRITE = 1, daher Sprung zum Schreiben
 01E  14844                       COMPARE STATE[s8], 44
 01F  35036                       JUMP Z, DATENUEBERNAHME[036]        ; Abspeichern der Datenbits und Übergang auf 88
 020  14888                       COMPARE STATE[s8], 88
 021  35040                       JUMP Z, CHECK_STOP_BIT[040]         ; Erkennen des Stopbits und Übergang auf 11
 022  14822                       COMPARE STATE[s8], 22
 023  3502A                       JUMP Z, STARTBITVALIDIERUNG[02A]    ; Wenn das Startbit 8 Takte vorliegt geht man in Zustand 44 über
 024                              ; ----------------------- Zustand ELSE : Flankenerkennung -----------------------------
 024                              ; Sobald im Zustand 11 eine Abwärtsflanke erkannt wird liegt das Startbit vor
 024             FLANK_DETECTION: 
 024  04001                       INPUT IOR[s0], COM_Port[01]         ; COM_Port einlesen
 025  14001                       COMPARE IOR[s0], 01                 ; Falls IOR 1 ist, also kein Startbit
 026  2B000                       RETURN Z                            ; Beende Einlesen
 027                              ; Ansonsten muss IOR bereits 0 sein -> nur noch 7 Takte abzählen
 027  00407                       LOAD COUNTER[s4], SEVEN[07]
 028  00822                       LOAD STATE[s8], 22                  ; Rotiere nach links von 11 nach 22
 029  2A000                       RETURN
 02A                              ; --------------------- Zustand 22 : Startbitvalidierung ----------------------------
 02A                              ; Hier werden nach Erkennung des Starbits 7 Takte abgezählt (insgesamt 8 mit Erkennung)
 02A         STARTBITVALIDIERUNG: 
 02A  1C401                       SUB COUNTER[s4], 01                 ; Dekrementieren von sieben bis null
 02B  2B400                       RETURN NZ                           ; Beenden sobald keine 8 Takte erreicht wurden
 02C  04001                       INPUT IOR[s0], COM_Port[01]         ; Nun muss Bit eingelesen und nochmals auf 0 geprüft werden (Rauschprävention)
 02D  14001                       COMPARE IOR[s0], 01                 ; IOR darf hier nicht 1 sein, sonst liegt ein Fehler vor -> Reset
 02E  35034                       JUMP Z, RAUSCHEN[034]
 02F  00500                       LOAD DATA[s5], 00
 030  00410                       LOAD COUNTER[s4], SIXTEEN[10]       ; Setze Counter zurück, sodass wir diesen später auf 16 zählen können
 031  00708                       LOAD DATA_COUNT[s7], EIGHT[08]      ; Counter um 8 Bits zu zählen bis Zeichen vollständig eingelesen ist
 032  00844                       LOAD STATE[s8], 44                  ; Zustandsübergang von 22 auf 44
 033  2A000                       RETURN                              ; Startbit muss nicht in Datenregister zurückgeschrieben werden, da es sowieso eine 0 ist
 034                              ; Falls ein Rauschen vorliegt auf Zustand 11 zurückgesetzt werden:
 034                    RAUSCHEN: 
 034  00811                       LOAD STATE[s8], 11                  ; Von 22 auf 11 zurück
 035  2A000                       RETURN
 036                              ; --------------------- Zustand 44 : Datenbits einlesen -----------------------------
 036                              ; Nach Ablauf von 16 Takten Bit einlesen und abspeichern
 036             DATENUEBERNAHME: 
 036  1C401                       SUB COUNTER[s4], 01                 ; Dekrementieren von sechzehn bis null
 037  2B400                       RETURN NZ
 038  04001                       INPUT IOR[s0], COM_Port[01]         ; Zunächst muss das Bit eingelesen werden
 039  0D500                       OR DATA[s5], IOR[s0]                ; Bit eintragen in Datenspeicher
 03A  2050C                       RR DATA[s5]                         ; Platz schaffen für nächstes Bit
 03B  00410                       LOAD COUNTER[s4], SIXTEEN[10]       ; Counter wieder zurücksetzen für nächstes Bit
 03C                              ; Wenn 8 Bits erreicht wurden, Übergang nach Zustand 88
 03C  1C701                       SUB DATA_COUNT[s7], 01              ; Dekrementieren von acht bis null
 03D  2B400                       RETURN NZ
 03E                              ; enter stopbit detection
 03E  00888                       LOAD STATE[s8], 88                  ; Zustandsübergang von 44 auf 88
 03F  2A000                       RETURN
 040                              ; --------------------- Zustand 88 : Stopbit erkennen -----------------------------
 040              CHECK_STOP_BIT: 
 040  1C401                       SUB COUNTER[s4], 01                 ; Counter wieder 16 Takte runterzählen
 041  2B400                       RETURN NZ
 042  04001                       INPUT IOR[s0], COM_Port[01]         ; Bit einlesen
 043  14001                       COMPARE IOR[s0], 01                 ; Schauen ob Stopbit vorliegt
 044  35434                       JUMP NZ, RAUSCHEN[034]              ; Stopbit liegt vor, Überprüfung des ASCII Zeichens
 045  1457B                       COMPARE DATA[s5], ENDKLEIN[7B]      ; ob größer z
 046  35C55                       JUMP NC, READ_RESET[055]
 047  14530                       COMPARE DATA[s5], BEGINZAHL[30]     ; Schauen ob wir kleiner als 0 sind
 048  35855                       JUMP C, READ_RESET[055]
 049  14561                       COMPARE DATA[s5], BEGINKLEIN[61]    ; Schauen ob Kleinbuchstabe vorliegt
 04A  35C52                       JUMP NC, WRITE_TO_RAM[052]
 04B  1455B                       COMPARE DATA[s5], ENDGROSS[5B]      ; Schauen ob zwischen Z und a
 04C  35C55                       JUMP NC, READ_RESET[055]
 04D  14541                       COMPARE DATA[s5], BEGINGROSS[41]    ; Schauen ob Großbuchstabe vorliegt
 04E  35C52                       JUMP NC, WRITE_TO_RAM[052]
 04F  1453A                       COMPARE DATA[s5], ENDZAHL[3A]       ; Schauen ob Zahl oder Sonderzeichen
 050  35852                       JUMP C, WRITE_TO_RAM[052]           ; Zahl liegt vor
 051  34055                       JUMP READ_RESET[055]                ; Sonderzeichen zwischen 9 und A liegt vor
 052                              ; Zeichen ist valide, kann also auf RAM geschrieben werden
 052                WRITE_TO_RAM: 
 052  2CB02                       OUTPUT ADR_R[sB], RAM_ADR[02]
 053  18B01                       ADD ADR_R[sB], ONE[01]
 054  2C504                       OUTPUT DATA[s5], RAM_DATA[04]       ; Schreibe Zeichen in Datenregister an Adresse von ADR
 055                              ; Zeichen ist komplett eingelesen, Zustände zurücksetzen
 055                  READ_RESET: 
 055  00811                       LOAD STATE[s8], 11
 056  1C901                       SUB DATABLOCK_COUNTER[s9], 01       ; Anzahl der noch zu lesenden ASCII-Zeichen reduzieren
 057  2B400                       RETURN NZ
 058  00601                       LOAD WRITE[s6], ONE[01]
 059  00410                       LOAD COUNTER[s4], SIXTEEN[10]
 05A  2CA09                       OUTPUT ADR_W[sA], PTR[09]           ; Startadresse setzen
 05B  2CB0B                       OUTPUT ADR_R[sB], LEN[0B]           ; Länge des Blocks mitgeben
 05C  2CD08                       OUTPUT Stopbit[sD], STATUS_REG[08]  ; Co-Prozessor starten
 05D  2A000                       RETURN
 05E                              ; ------------------- Zustandsautomat zum Festlegen des Lesezustandes ------------------------
 05E                    COMM_OUT: 
 05E                              ; zyklisches Abprüfen der DONE Variable, STRT wird hierbei stets auf 00 gesetzt
 05E  04008                       INPUT IOR[s0], STATUS_REG[08]       ; Schauen ob Co-Prozessor DONE ist
 05F  14000                       COMPARE IOR[s0], ZERO[00]
 060  2CC08                       OUTPUT Startbit[sC], STATUS_REG[08] ; STARTBIT entspricht 00, setze somit Co-Prozessor STRT auf 0
 061                              ; -------------------------------------
 061  2B000                       RETURN Z
 062  14822                       COMPARE STATE[s8], 22
 063  35070                       JUMP Z, WRITE_DATABIT[070]          ; Schreiben des Datenbits
 064  14844                       COMPARE STATE[s8], 44
 065  35079                       JUMP Z, WRITE_STOPBIT[079]          ; Stopbit schreiben und Schreibprozess beenden
 066                              ; --------------------------- Zustand ELSE : Startbit schreiben --------------------------------
 066              WRITE_STARTBIT: 
 066  1C401                       SUB COUNTER[s4], ONE[01]
 067  2B400                       RETURN NZ
 068  2CC01                       OUTPUT Startbit[sC], COM_Port[01]
 069  00410                       LOAD COUNTER[s4], SIXTEEN[10]
 06A  00708                       LOAD DATA_COUNT[s7], EIGHT[08]
 06B                              ; ---- Byte aus RAM Lesen ----------
 06B  2CA02                       OUTPUT ADR_W[sA], RAM_ADR[02]
 06C  18A01                       ADD ADR_W[sA], 01
 06D  04504                       INPUT DATA[s5], RAM_DATA[04]
 06E                              ; ----------------------------------
 06E  00822                       LOAD STATE[s8], 22
 06F  2A000                       RETURN
 070                              ; --------------------------- Zustand 22 : Datenbit schreiben ---------------------------------
 070               WRITE_DATABIT: 
 070  1C401                       SUB COUNTER[s4], 01                 ; Dekrementieren von sechzehn auf null
 071  2B400                       RETURN NZ
 072  00410                       LOAD COUNTER[s4], SIXTEEN[10]       ; Wieder auf sechzehn setzen
 073  2C501                       OUTPUT DATA[s5], COM_Port[01]       ; LSB auf COM_Port schreiben
 074  2050E                       SR0 DATA[s5]                        ; LSB flushen
 075  1C701                       SUB DATA_COUNT[s7], 01              ; Falls DATA_COUNT 0 ist wurden 8 bits geschrieben
 076  2B400                       RETURN NZ
 077                              ; Ansonsten muss als nächstes Stopbit gesetzt werden
 077  00844                       LOAD STATE[s8], 44                  ; Übergang von 22 auf 44
 078  2A000                       RETURN
 079                              ; --------------------------- Zustand 44 : Stopbit schreiben --------------------------------
 079               WRITE_STOPBIT: 
 079  1C401                       SUB COUNTER[s4], 01
 07A  2B400                       RETURN NZ
 07B  2CD01                       OUTPUT Stopbit[sD], COM_Port[01]    ; Stopbit schreiben
 07C  00410                       LOAD COUNTER[s4], SIXTEEN[10]
 07D  00811                       LOAD STATE[s8], 11
 07E                              ; Semaphor wieder auf 0, falls Datenblock aus RAM gelesen wurde
 07E  15AB0                       COMPARE ADR_W[sA], ADR_R[sB]
 07F  2B400                       RETURN NZ
 080  00600                       LOAD WRITE[s6], ZERO[00]
 081  009FF                       LOAD DATABLOCK_COUNTER[s9], FF
 082  00A00                       LOAD ADR_W[sA], ZERO[00]
 083  00B00                       LOAD ADR_R[sB], ZERO[00]
 084  2A000                       RETURN
 085                              ; --------------------------------------------------------------------------------------------
 300                              ADDRESS 300
 300                              ; Interrupt-Service-Routine
 300  3000C                  ISR: CALL BNT0LED0[00C]
 301  30015                       CALL BLINK[015]
 302  3001C                       CALL COMM_IN[01C]
 303  38001                       RETURNI ENABLE
 304                              ; --------------------------------------------------------------------------------------------
 304                              ; Interrupt-Vektor
 3FF                              ADDRESS 3FF
 3FF  34300                       JUMP ISR[300]
